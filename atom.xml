<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[I'm Jony]]></title>
  <link href="http://jonyfang.com/atom.xml" rel="self"/>
  <link href="http://jonyfang.com/"/>
  <updated>2016-09-04T11:27:15+08:00</updated>
  <id>http://jonyfang.com/</id>
  <author>
    <name><![CDATA[Jony Fang]]></name>
    <email><![CDATA[jony.chunfang@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[数据结构浅析（四）：栈和队列]]></title>
    <link href="http://jonyfang.com/blog/2016/04/18/data-structure04-stack-and-queue/"/>
    <updated>2016-04-18T14:30:23+08:00</updated>
    <id>http://jonyfang.com/blog/2016/04/18/data-structure04-stack-and-queue</id>
    <content type="html"><![CDATA[<p class="info">什么是栈？
栈有哪些存储方式？
栈有哪些应用？
<br />
什么是队列？
队列有哪些存储方式？
<br />
本篇总结了这几个问题</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1.栈</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">1.1.栈的定义</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">1.2.	栈的顺序存储结构及实现</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">1.3.两栈共享空间</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">1.4.栈的链式存储结构（链栈）及实现</a></li>
    </ul>
  </li>
  <li><a href="#section-5" id="markdown-toc-section-5">2.栈的应用－－递归</a>    <ul>
      <li><a href="#fibonacci" id="markdown-toc-fibonacci">2.1.斐波那契数列（Fibonacci）实现</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">2.2.递归定义</a></li>
    </ul>
  </li>
  <li><a href="#section-7" id="markdown-toc-section-7">3.栈的应用－－四则运算表达式求值</a>    <ul>
      <li><a href="#section-8" id="markdown-toc-section-8">3.1.后缀（逆波兰）表示法应用</a></li>
      <li><a href="#section-9" id="markdown-toc-section-9">3.2.中缀表达式转后缀表达式</a></li>
    </ul>
  </li>
  <li><a href="#section-10" id="markdown-toc-section-10">4.队列</a>    <ul>
      <li><a href="#section-11" id="markdown-toc-section-11">4.1.队列定义</a></li>
      <li><a href="#section-12" id="markdown-toc-section-12">4.2.循环对列</a>        <ul>
          <li><a href="#section-13" id="markdown-toc-section-13">4.2.1.循环对列</a></li>
          <li><a href="#section-14" id="markdown-toc-section-14">4.2.2.对列的链式存储结构及实现</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-15" id="markdown-toc-section-15">5.总结</a></li>
</ul>

<!-- more -->

<h1 id="section">1.栈</h1>

<h2 id="section-1">1.1.栈的定义</h2>

<p>栈（stack）是限定仅在表尾（栈顶 top）进行插入和删除操作的后进先出的线性表。</p>

<p>push、pop 操作在栈顶进行。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">ADT 栈(stack)
</span><span class="line">Data
</span><span class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
</span><span class="line">Operation
</span><span class="line">    InitStack(*S):    初始化操作，建立一个空栈S。
</span><span class="line">    DestroyStack(*S): 若栈存在，则销毁它。
</span><span class="line">    ClearStack(*S):   将栈清空。
</span><span class="line">    StackEmpty(S):    若栈为空，返回true，否则返回false。
</span><span class="line">    GetTop(S, *e):    若栈存在且非空，用e返回S的栈顶元素。
</span><span class="line">    Push(*S, e):      若栈S存在，插入新元素e到栈S中并成为栈顶元素。
</span><span class="line">    Pop(*S, *e):      删除栈S中栈顶元素，并用e返回其值。
</span><span class="line">    StackLength(S):   返回栈S的元素个数。
</span><span class="line">endADT</span></code></pre></td></tr></table></div></figure></notextile></div>

<hr />

<h2 id="section-2">1.2.	栈的顺序存储结构及实现</h2>

<p>栈的结构定义</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* SElemType类型根据实际情况而定，这里假设为int */
</span><span class="line">typedef int SElemType;    
</span><span class="line">typedef struct
</span><span class="line">{
</span><span class="line">    SElemType data[MAXSIZE];
</span><span class="line">    /* 用于栈顶指针 */
</span><span class="line">    int top;              
</span><span class="line">}SqStack; </span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E6%A0%88%E6%99%AE%E9%80%9A3%E7%A7%8D%E7%8A%B6%E6%80%81.png" alt="栈普通3种状态" /></p>

<p>现在有一个栈，StackSize是5，则栈普通情况、空栈和栈满的情况、空栈和栈满的情况示意图如上</p>

<p>进栈(push)：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 插入元素e为新的栈顶元素 */
</span><span class="line">Status Push(SqStack *S, SElemType e)
</span><span class="line">{
</span><span class="line">    /* 栈满 */
</span><span class="line">    if (S-&gt;top == MAXSIZE - 1)    
</span><span class="line">    {
</span><span class="line">        return ERROR;
</span><span class="line">    }
</span><span class="line">    /* 栈顶指针增加一 */
</span><span class="line">    S-&gt;top++;                     
</span><span class="line">    /* 将新插入元素赋值给栈顶空间 */
</span><span class="line">    S-&gt;data[S-&gt;top] = e;          
</span><span class="line">    
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>出栈(pop):</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，
</span><span class="line">   并返回OK；否则返回ERROR */
</span><span class="line">Status Pop(SqStack *S, SElemType *e)
</span><span class="line">{
</span><span class="line">    if (S-&gt;top == -1)
</span><span class="line">        return ERROR;
</span><span class="line">    /* 将要删除的栈顶元素赋值给e */
</span><span class="line">    *e = S-&gt;data[S-&gt;top];    
</span><span class="line">    /* 栈顶指针减一 */
</span><span class="line">    S-&gt;top--;  
</span><span class="line">                  
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>
<hr />

<h2 id="section-3">1.3.两栈共享空间</h2>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4.png" alt="两栈共享空间" /></p>

<p>数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为数组的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。（只针对两个具有相同数据类型的栈）</p>

<p>栈1为空时，即top1等于-1时；栈2为空时，即top2等于n时；栈满时，即top1+1==top2时。</p>

<p>两栈共享空间的结构的代码:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 两栈共享空间结构 */
</span><span class="line">typedef struct
</span><span class="line">{
</span><span class="line">    SElemType data[MAXSIZE];
</span><span class="line">    int top1;    /* 栈1栈顶指针 */
</span><span class="line">    int top2;    /* 栈2栈顶指针 */
</span><span class="line">} SqDoubleStack;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于两栈共享空间的push方法，除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber。插入元素的代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 插入元素e为新的栈顶元素 */
</span><span class="line">Status Push(SqDoubleStack *S, SElemType e, 
</span><span class="line">int stackNumber)
</span><span class="line">{
</span><span class="line">    /* 栈已满，不能再push新元素了 */
</span><span class="line">    if (S-&gt;top1 + 1 == S-&gt;top2)    
</span><span class="line">        return ERROR;
</span><span class="line">    /* 栈1有元素进栈 */
</span><span class="line">    if (stackNumber == 1)          
</span><span class="line">        /* 若栈1则先top1+1后给数组元素赋值 */
</span><span class="line">        S-&gt;data[++S-&gt;top1] = e;    
</span><span class="line">    /* 栈2有元素进栈 */
</span><span class="line">    else if (stackNumber == 2)     
</span><span class="line">        /* 若栈2则先top2-1后给数组元素赋值 */
</span><span class="line">        S-&gt;data[--S-&gt;top2] = e;    
</span><span class="line">        
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于两栈共享空间的pop方法，参数就只是判断栈1栈2的参数stackNumber，代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，
</span><span class="line">   并返回OK；否则返回ERROR */
</span><span class="line">Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber)
</span><span class="line">{
</span><span class="line">    if (stackNumber == 1)
</span><span class="line">    {
</span><span class="line">        /* 说明栈1已经是空栈，溢出 */
</span><span class="line">        if (S-&gt;top1 == -1)
</span><span class="line">            return ERROR;
</span><span class="line">        /* 将栈1的栈顶元素出栈 */
</span><span class="line">        *e = S-&gt;data[S-&gt;top1--];    
</span><span class="line">    }
</span><span class="line">    else if (stackNumber == 2)
</span><span class="line">    {
</span><span class="line">        /* 说明栈2已经是空栈，溢出 */
</span><span class="line">        if (S-&gt;top2 == MAXSIZE)
</span><span class="line">            return ERROR;           
</span><span class="line">        /* 将栈2的栈顶元素出栈 */
</span><span class="line">        *e = S-&gt;data[S-&gt;top2++];    
</span><span class="line">    }
</span><span class="line">    
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-4">1.4.栈的链式存储结构（链栈）及实现</h2>

<p>链栈的结构代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">typedef struct StackNode
</span><span class="line">{
</span><span class="line">    SElemType data;
</span><span class="line">    struct StackNode *next;
</span><span class="line">} StackNode, *LinkStackPtr;
</span><span class="line">
</span><span class="line">typedef struct LinkStack
</span><span class="line">{
</span><span class="line">    LinkStackPtr top;
</span><span class="line">    int count;
</span><span class="line">} LinkStack;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>进栈：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 插入元素e为新的栈顶元素 */
</span><span class="line">Status Push(LinkStack *S, SElemType e)
</span><span class="line">{
</span><span class="line">    LinkStackPtr s 
</span><span class="line">      = (LinkStackPtr)malloc(sizeof(StackNode));
</span><span class="line">    s-&gt;data = e;
</span><span class="line">    /* 把当前的栈顶元素赋值给新结点的直接后继，如图中① */
</span><span class="line">    s-&gt;next = S-&gt;top;    
</span><span class="line">    /* 将新的结点s赋值给栈顶指针，如图中② */
</span><span class="line">    S-&gt;top = s;          
</span><span class="line">    S-&gt;count++;
</span><span class="line">    
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>出栈：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，
</span><span class="line">   并返回OK；否则返回ERROR */
</span><span class="line">Status Pop(LinkStack *S, SElemType *e)
</span><span class="line">{
</span><span class="line">    LinkStackPtr p;
</span><span class="line">    if (StackEmpty(*S))
</span><span class="line">        return ERROR;
</span><span class="line">    *e = S-&gt;top-&gt;data;
</span><span class="line">    /* 将栈顶结点赋值给p，如图③ */
</span><span class="line">    p = S-&gt;top;               
</span><span class="line">    /* 使得栈顶指针下移一位，指向后一结点，如图④ */
</span><span class="line">    S-&gt;top = S-&gt;top-&gt;next;    
</span><span class="line">    /* 释放结点p */
</span><span class="line">    free(p);                  
</span><span class="line">    S-&gt;count--;
</span><span class="line">    
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<hr />

<h1 id="section-5">2.栈的应用－－递归</h1>

<h2 id="fibonacci">2.1.斐波那契数列（Fibonacci）实现</h2>

<p>问：如果兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔都不死，那么一年以后可以繁殖多少对兔子呢？</p>

<p>分析：拿新出生的一对小兔子分析一下：第一个月小兔子没有繁殖能力，所以还是一对；两个月后，生下一对小兔子数共有两对；三个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，所以一共是三对……</p>

<p>依次类推可以列出下表：</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-tuzi.png" alt="" /></p>

<p>表中数字1，1，2，3，5，8，13……构成了一个序列。这个数列有个十分明显的特点，前面相邻两项之和，构成了后一项</p>

<p>如下图：
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E4%B8%A4%E9%A1%B9%E4%B9%8B%E5%92%8C%EF%BC%9D%E4%B8%8B%E4%B8%80%E9%A1%B9.png" alt="" /></p>

<p>对应的数学函数：
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%85%94%E5%AD%90%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="" /></p>

<p>打印出前40位的斐波那契数列数:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int main()
</span><span class="line">{
</span><span class="line">    int i;
</span><span class="line">    int a[40];
</span><span class="line">    a[0] = 0;
</span><span class="line">    a[1] = 1;
</span><span class="line">    printf("%d ", a[0]);
</span><span class="line">    printf("%d ", a[1]);
</span><span class="line">    for (i = 2; i &lt; 40; i++)
</span><span class="line">    {
</span><span class="line">        a[i] = a[i - 1] + a[i - 2];
</span><span class="line">        printf("%d ", a[i]);
</span><span class="line">    }
</span><span class="line">    return 0;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>其实我们的代码，如果用递归来实现，还可以更简单:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 斐波那契的递归函数 */ 
</span><span class="line">int Fbi(int i)
</span><span class="line">{
</span><span class="line">    if (i &lt; 2)
</span><span class="line">        return i == 0 ? 0 : 1;
</span><span class="line">    /* 这里Fbi就是函数自己，它在调用自己 */
</span><span class="line">    return Fbi(i - 1) + Fbi(i - 2);    
</span><span class="line">}
</span><span class="line">int main()
</span><span class="line">{
</span><span class="line">    int i;
</span><span class="line">    for (i = 0; i &lt; 40; i++)
</span><span class="line">        printf("%d ", Fbi(i));
</span><span class="line">    return  0;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>相比较迭代的代码，是不是干净很多。
那么这段递归是怎么执行的呢？我们来模拟代码种的 Fbi(i) 函数当 i=5 的执行过程，如下图：</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_Fbi(5)%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Fbi(5)执行过程" /></p>

<h2 id="section-6">2.2.递归定义</h2>

<p>迭代和递归的区别是：
迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。</p>

<p>递归与栈有什么关系？
这得从计算机系统的内部说起，前面我们已经看到递归是如何执行它的前行(Fbi(i))和退回(return)阶段的。递归过程退回的顺序是它前行顺序的逆序。在退回过程中，可能要执行某些动作，包括恢复在前行过程中存储起来的某些数据。</p>

<p>这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合栈这样的数据结构，因此，编译器使用栈实现递归就没什么好惊讶的了。</p>

<p>简单的说，就是在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。</p>

<h1 id="section-7">3.栈的应用－－四则运算表达式求值</h1>

<h2 id="section-8">3.1.后缀（逆波兰）表示法应用</h2>

<p>对于“9+(3-1)×3+10÷2”，如果要用后缀表示法应该是什么样子：“9 3 1-3*+102/+”，这样的表达式称为后缀表达式，叫后缀的原因在于所有的符号都是在要运算数字的后面出现。</p>

<p>举例：
后缀表达式：9 3 1-3*+10 2/+</p>

<p>规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p>

<p>1．初始化一个空栈。此栈用来对要运算的数字进出使用；
2．后缀表达式中前三个都是数字，所以9、3、1进栈；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F01.png" alt="" />
3．接下来是“-”，所以将栈中的1出栈作为减数，3出栈作为被减数，并运算3-1得到2，再将2进栈；
4．接着是数字3进栈；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F02.png" alt="" />
5．后面是“*”，也就意味着栈中3和2出栈，2与3相乘，得到6，并将6进栈；
6．下面是“+”，所以栈中6和9出栈，9与6相加，得到15，将15进栈；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F03.png" alt="" />
7．接着是10与2两数字进栈；
8．接下来是符号“/”，因此，栈顶的2与10出栈，10与2相除，得到5，将5进栈；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F04.png" alt="" />
9．最后一个是符号“+”，所以15与5出栈并相加，得到20，将20进栈，如图4-9-5的左图所示。10．结果是20出栈，栈变为空
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F05.png" alt="" /></p>

<p>很顺利的解决了计算的问题，那么如何让“9+(3-1)×3+10÷2”转化为“9 3 1-3+10 2/+”呢？</p>

<h2 id="section-9">3.2.中缀表达式转后缀表达式</h2>

<p>“9+(3-1)×3+10÷2”这样平时所用的标准四则运算表达式，因为所有的运算符号都在两数字之间，所以叫做中缀表达式。</p>

<p>中缀表达式“9+(3-1)×3+10÷2”转化为后缀表达式“9 3 1-3*+10 2/+”</p>

<p>规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</p>

<p>1．初始化一空栈，用来对符号进出栈使用；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F01.png" alt="" />
2．第一个字符是数字9，输出9，后面是符号“+”，进栈；
3．第三个字符是“(”，依然是符号，因其只是左括号，还未配对，故进栈；
4．第四个字符是数字3，输出，总表达式为93，接着是“-”，进栈；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F02.png" alt="" />
5．接下来是数字1，输出，总表达式为 9 31，后面是符号“)”，此时，我们需要去匹配此前的“(”，所以栈顶依次出栈，并输出，直到“(”出栈为止。此时左括号上方只有“-”，因此输出“-”。总的输出表达式为 9 3 1-；
6．紧接着是符号“×”，因为此时的栈顶符号为“+”号，优先级低于“×”，因此不输出，“<em>”进栈。接着是数字3，输出，总的表达式为 9 3 1-3；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F03.png" alt="" />
7．之后是符号“+”，此时当前栈顶元素“”比这个“+”的优先级高，因此栈中元素出栈并输出（没有比“+”号更低的优先级，所以全部出栈），总输出表达式为9 3 1-3+。然后将当前这个符号“+”进栈。也就是说，前6张图的栈底的“+”是指中缀表达式中开头的9后面那个“+”，而图4-9-9左图中的栈底（也是栈顶）的“+”是指“9+(3-1)×3+”中的最后一个“+”；
8．紧接着数字10，输出，总表达式变为9 31-3</em>+10。后是符号“÷”，所以“/”进栈；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F04.png" alt="" />
9．最后一个数字2，输出，总的表达式为9 31-3+10 2。如图4-9-10的左图所示。10．因已经到最后，所以将栈中符号全部出栈并输出。最终输出的后缀表达式结果为93 1-3+10 2/+”；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F05.png" alt="" /></p>

<hr />

<h1 id="section-10">4.队列</h1>

<h2 id="section-11">4.1.队列定义</h2>

<p>队列（queue）是一种先进先出（First In First Out）的线性表，简称FIFO。只允许在一端进行插入操作，而在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">ADT 队列(Queue)
</span><span class="line">Data
</span><span class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
</span><span class="line">Operation
</span><span class="line">    InitQueue(*Q):    初始化操作，建立一个空队列Q。
</span><span class="line">    DestroyQueue(*Q): 若队列Q存在，则销毁它。
</span><span class="line">    ClearQueue(*Q):   将队列Q清空。
</span><span class="line">    QueueEmpty(Q):    若队列Q为空，返回true，否则返回false。
</span><span class="line">    GetHead(Q, *e):   若队列Q存在且非空，用e返回队列Q的队头元素。
</span><span class="line">    EnQueue(*Q, e):   若队列Q存在，插入新元素e到队列Q中并成为队尾元素。
</span><span class="line">    DeQueue(*Q, *e):  删除队列Q中队头元素，并用e返回其值。
</span><span class="line">    QueueLength(Q):   返回队列Q的元素个数
</span><span class="line">endADT</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-12">4.2.循环对列</h2>

<h3 id="section-13">4.2.1.循环对列</h3>

<p>首先了解下，什么是假溢出：
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%BE%AA%E7%8E%AF%E5%AF%B9%E5%88%9701.png" alt="" />
假设这个队列的总个数不超过5个，但目前如果接着入队的话，因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上，我们的队列在下标为0和1的地方还是空闲的。我们把这种现象叫做“假溢出”。</p>

<p>解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。这种头尾相接的顺序存储结构就是循环队列。</p>

<p>此时问题出来了，空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？</p>

<ul>
  <li>办法一是设置一个标志变量flag，当front==rear，且flag=0时为队列空，当front==rear，且flag=1时为队列满。</li>
  <li>办法二是当队列空时，条件就是front=rear，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。例如图4-12-8所示，我们就认为此队列已经满了，也就是说，我们不允许图4-12-7的右图情况出现。
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%BE%AA%E7%8E%AF%E5%AF%B9%E5%88%9702.png" alt="" /></li>
</ul>

<p>问题又来了，第二种方法，由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。
若队列的最大尺寸为QueueSize，那么队列满的条件是(rear+1)%QueueSize==front（取模“%”的目的就是为了整合rear与front大小为一个问题）。</p>

<p>另外，当rear&gt;front时，此时队列的长度为rear-front。但当rear&lt;front时，队列长度分为两段，一段是QueueSize-front，另一段是0+rear，加在一起，队列长度为rear-front+QueueSize。
因此通用的计算队列长度公式为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(rear-front+QueueSize)%QueueSize</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>有了这些讲解，现在实现循环队列就不难了。</p>

<p>循环队列的顺序存储结构代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* QElemType类型根据实际情况而定，这里假设为int */
</span><span class="line">typedef int QElemType;    
</span><span class="line">/* 循环队列的顺序存储结构 */
</span><span class="line">typedef struct
</span><span class="line">{
</span><span class="line">    QElemType data[MAXSIZE];
</span><span class="line">    /* 头指针 */
</span><span class="line">    int front;            
</span><span class="line">    /* 尾指针，若队列不空，
</span><span class="line">       指向队列尾元素的下一个位置 */
</span><span class="line">    int rear;             
</span><span class="line">} SqQueue;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>循环队列的初始化代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 初始化一个空队列Q */
</span><span class="line">Status InitQueue(SqQueue *Q)
</span><span class="line">{
</span><span class="line">    Q-&gt;front = 0;
</span><span class="line">    Q-&gt;rear = 0;    
</span><span class="line">    
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>循环队列求队列长度代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 返回Q的元素个数，也就是队列的当前长度 */
</span><span class="line">int QueueLength(SqQueue Q)
</span><span class="line">{
</span><span class="line">    return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>循环队列的入队列操作代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 若队列未满，则插入元素e为Q新的队尾元素 */
</span><span class="line">Status EnQueue(SqQueue *Q, QElemType e)
</span><span class="line">{
</span><span class="line">    /* 队列满的判断 */
</span><span class="line">    if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)    
</span><span class="line">        return ERROR;
</span><span class="line">    /* 将元素e赋值给队尾 */
</span><span class="line">    Q-&gt;data[Q-&gt;rear] = e;                       
</span><span class="line">    /* rear指针向后移一位置， */
</span><span class="line">    Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;          
</span><span class="line">    /* 若到最后则转到数组头部 */
</span><span class="line">    
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>循环队列的出队列操作代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 若队列不空，则删除Q中队头元素，用e返回其值 */
</span><span class="line">Status DeQueue(SqQueue *Q, QElemType *e)
</span><span class="line">{
</span><span class="line">    /* 队列空的判断 */
</span><span class="line">    if (Q-&gt;front == Q-&gt;rear)                
</span><span class="line">        return ERROR;
</span><span class="line">    /* 将队头元素赋值给e */
</span><span class="line">    *e = Q-&gt;data[Q-&gt;front];                 
</span><span class="line">    /* front指针向后移一位置， */
</span><span class="line">    Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;    
</span><span class="line">    /* 若到最后则转到数组头部 */
</span><span class="line">    return  OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>到这里可以看出单是顺序存储，若不是循环队列，算法的时间性能是不高的，但循环队列又面临着数组可能会溢出的问题，所以我们还需要研究一下不需要担心队列长度的链式存储结构。</p>

<h3 id="section-14">4.2.2.对列的链式存储结构及实现</h3>

<p>链对列的结构：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* QElemType类型根据实际情况而定，这里假设为int */
</span><span class="line">typedef int QElemType;       
</span><span class="line">/* 结点结构 */
</span><span class="line">typedef struct QNode         
</span><span class="line">{
</span><span class="line">    QElemType data;
</span><span class="line">    struct QNode *next;
</span><span class="line">} QNode, *QueuePtr;
</span><span class="line">
</span><span class="line">/* 队列的链表结构 */
</span><span class="line">typedef struct               
</span><span class="line">{
</span><span class="line">    /* 队头、队尾指针 */
</span><span class="line">    QueuePtr front, rear;    
</span><span class="line">} LinkQueue;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>入对列：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 插入元素e为Q的新的队尾元素 */
</span><span class="line">Status EnQueue(LinkQueue *Q, QElemType e)
</span><span class="line">{
</span><span class="line">    QueuePtr s = 
</span><span class="line">(QueuePtr)malloc(sizeof(QNode));
</span><span class="line">    /* 存储分配失败 */
</span><span class="line">    if (!s)               
</span><span class="line">        exit(OVERFLOW);
</span><span class="line">    s-&gt;data = e;
</span><span class="line">    s-&gt;next = NULL;
</span><span class="line">    /* 把拥有元素e新结点s赋值给原队尾结点的后继， */
</span><span class="line">    Q-&gt;rear-&gt;next = s;    
</span><span class="line">    /* 见上图中① */
</span><span class="line">    /* 把当前的s设置为队尾结点，rear指向s，见上图中② */
</span><span class="line">    Q-&gt;rear = s;  
</span><span class="line">            
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>出对列：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 若队列不空，删除Q的队头元素，用e返回其值，
</span><span class="line">并返回OK，否则返回ERROR */
</span><span class="line">Status DeQueue(LinkQueue *Q, QElemType *e)
</span><span class="line">{
</span><span class="line">    QueuePtr p;
</span><span class="line">    if (Q-&gt;front == Q-&gt;rear)
</span><span class="line">        return ERROR;
</span><span class="line">    /* 将欲删除的队头结点暂存给p，见上图中① */
</span><span class="line">    p = Q-&gt;front-&gt;next;          
</span><span class="line">    /* 将欲删除的队头结点的值赋值给e */
</span><span class="line">    *e = p-&gt;data;                
</span><span class="line">    /* 将原队头结点后继p-&gt;next赋值给头结点后继， */
</span><span class="line">    Q-&gt;front-&gt;next = p-&gt;next;    
</span><span class="line">    /* 见上图中② */
</span><span class="line">    /* 若队头是队尾，则删除后将rear指向头结点，见上图中③ */
</span><span class="line">    if (Q-&gt;rear == p)            
</span><span class="line">        Q-&gt;rear = Q-&gt;front;
</span><span class="line">    free(p);
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于循环队列与链队列的比较，可以从两方面来考虑，从时间上，其实它们的基本操作都是常数时间，即都为O(1)的，不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。</p>

<p>总的来说，在可以确定队列长度最大值的情况下，可以用循环队列，如果无法预估队列的长度时，则用链队列。</p>

<hr />

<h1 id="section-15">5.总结</h1>
<p>栈（stack）是限定仅在表尾进行插入和删除操作的线性表。</p>

<p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>

<p>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。因此它们各自有各自的技巧来解决这个问题。</p>

<p>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。</p>

<p>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构浅析（三）：线性表]]></title>
    <link href="http://jonyfang.com/blog/2016/01/10/data_structure03.linear_list/"/>
    <updated>2016-01-10T20:30:00+08:00</updated>
    <id>http://jonyfang.com/blog/2016/01/10/data_structure03.linear_list</id>
    <content type="html"><![CDATA[<p class="info">什么是线性表？
<br />
线性表的两大存储结构是什么？
<br />
各种存储结构是如何实现存取、插入删除等操作的？
<br />
本篇主要解答了这几个问题，感兴趣的话一起来看看吧～</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">一. 什么是线性表？</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">二. 线性表的顺序存储结构</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">2.1、顺序存储需要什么？</a></li>
    </ul>
  </li>
  <li><a href="#section-3" id="markdown-toc-section-3">三. 顺序存储结构的插入与删除</a>    <ul>
      <li><a href="#section-4" id="markdown-toc-section-4">3.1、获取元素</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">3.2、插入新元素</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">3.3、删除元素</a></li>
    </ul>
  </li>
  <li><a href="#section-7" id="markdown-toc-section-7">四. 线性表的链式存储结构</a>    <ul>
      <li><a href="#section-8" id="markdown-toc-section-8">4.1、头结点</a></li>
      <li><a href="#section-9" id="markdown-toc-section-9">4.2、最后一个结点</a></li>
    </ul>
  </li>
  <li><a href="#section-10" id="markdown-toc-section-10">五. 单链表</a>    <ul>
      <li><a href="#section-11" id="markdown-toc-section-11">5.1、单链表的读取</a></li>
      <li><a href="#section-12" id="markdown-toc-section-12">5.2、单链表的插入和删除</a></li>
      <li><a href="#section-15" id="markdown-toc-section-15">5.3、单链表的整表创建</a></li>
      <li><a href="#section-16" id="markdown-toc-section-16">5.4、单链表的整表删除</a></li>
      <li><a href="#section-17" id="markdown-toc-section-17">5.5、单链表结构与顺序结构对比</a></li>
    </ul>
  </li>
  <li><a href="#section-18" id="markdown-toc-section-18">六. 静态链表</a>    <ul>
      <li><a href="#section-19" id="markdown-toc-section-19">6.1、什么是静态链表？</a></li>
      <li><a href="#section-20" id="markdown-toc-section-20">6.2、静态链表的插入操作</a></li>
      <li><a href="#section-21" id="markdown-toc-section-21">6.3、静态链表的删除操作</a></li>
      <li><a href="#section-22" id="markdown-toc-section-22">6.4、静态链表优缺点</a></li>
    </ul>
  </li>
  <li><a href="#section-23" id="markdown-toc-section-23">七. 循环链表</a></li>
  <li><a href="#section-24" id="markdown-toc-section-24">八. 双向链表</a></li>
</ul>

<!-- more -->

<h2 id="section">一. 什么是线性表？</h2>

<p><code>线性表</code>从字面大概能想象出线的样式，那么怎么样才算是一个线性表呢？这里有一个定义：零个或多个数据元素的有限序列称为<code>线性表（List）</code>。元素之间是有序的，若有多个元素，则第一个元素无前驱，最后一个元素无后继，其他每个元素只有一个前驱和后继。</p>

<h2 id="section-1">二. 线性表的顺序存储结构</h2>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%A4%BA%E6%84%8F%E5%9B%BE1.png" alt="线性表的顺序存储示意图" /></p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%A4%BA%E6%84%8F%E5%9B%BE2.png" alt="线性表的顺序存储示意图" /></p>

<p>线性表的<code>顺序存储结构</code>是线性表<code>物理结构</code>中的一种，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p>

<h3 id="section-2">2.1、顺序存储需要什么？</h3>

<p>描述顺序存储结构需要的三个属性：
- 存储空间的起始位置：数组 data 的存储位置就是存储空间的存储位置；
- 线性表的最大存储容量：数组长度 MaxSize；
- 线性表的当前长度：length.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"> <span class="cp">#define MAXSIZE 20 </span><span class="cm">/* 存储空间的初始分配量 */</span><span class="cp"></span>
</span><span class="line"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">ElemType</span><span class="p">;</span> <span class="cm">/* ElemType 类型视实际而定，这里为 int */</span>
</span><span class="line"><span class="k">typedef</span> <span class="k">struct</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="p">];</span> <span class="cm">/* 数组存储数据元素，最大值为 MAXSIZE */</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>  <span class="n">SqList</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>这里的数组 data 长度与线性表长度有什么区别？</strong></p>

<p>数组长度在创建之初就已经知道了，这个量一般是不变的；
线性表长度是线性表中数据元素的个数，它会随着线性表的插入、删除操作而变化；
任何时刻，线性表长度小于或等于数组长度.</p>

<h2 id="section-3">三. 顺序存储结构的插入与删除</h2>

<h3 id="section-4">3.1、获取元素</h3>

<p>对于线性表的顺序存储结构，如果我们要实现 GetElem 操作，只需将线性表 L 中第 i 个位置的元素值返回即可.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"> <span class="cp">#define OK 1</span>
</span><span class="line"> <span class="cp">#define ERROR 0</span>
</span><span class="line"> <span class="cp">#define TRUE 1</span>
</span><span class="line"> <span class="cp">#define FALSE 0</span>
</span><span class="line"> <span class="k">typedef</span> <span class="kt">int</span> <span class="n">Status</span><span class="p">;</span>  <span class="cm">/* Status 的值是函数的结果状态，如 OK 等 */</span>
</span><span class="line">
</span><span class="line"> <span class="cm">/* 初始条件：顺序线性表 L 已存在，1 &lt;= i &lt;= ListLength(L) */</span>
</span><span class="line"> <span class="cm">/* 操作结果：用 e 返回 L 中第 i 个数据元素的值 */</span>
</span><span class="line"> <span class="n">Status</span> <span class="n">GetElem</span><span class="p">(</span><span class="n">SqList</span> <span class="n">L</span><span class="p">;</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ElemType</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
</span><span class="line"> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
</span><span class="line">    <span class="o">*</span> <span class="n">e</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span><span class="line"> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-5">3.2、插入新元素</h3>

<p>如果我们要实现 Listin-sert(*L, i, e)，即怎么在线性表 L 中的第 i 个位置插入新元素 e？这里就用到了插入算法。</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B.png" alt="插入元素过程" /></p>

<p><strong>插入算法思路：</strong> 
- 如果插入位置不合理，抛出异常；
- 如果线性表长度 &gt;= 数组长度，抛出异常或动态增加容量；
- 从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置；
- 将要插入元素填入位置 i 处，线性表长+1.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 初始条件：顺序线性表 L 已存在，1 &lt;= i &lt;= ListLength(L) */</span>
</span><span class="line"><span class="cm">/* 操作结果：在 L 中第 i 个位置之前插入新的数据元素 e，L 长度为加 1 */</span>
</span><span class="line"><span class="n">Status</span> <span class="nf">ListInsert</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ElemType</span> <span class="n">e</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/* 顺序线性表已经满 */</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">==</span> <span class="n">MAXSIZE</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/* 当i不在范围内时 */</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">L</span><span class="o">-&gt;</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/* 若插入数据位置不在表尾 */</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="cm">/*将要插入位置后数据元素向后移动一位 */</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">i</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span><span class="o">--</span><span class="p">)</span>
</span><span class="line">            <span class="n">L</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">L</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="cm">/* 将新元素插入 */</span>
</span><span class="line">    <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-6">3.3、删除元素</h3>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B.png" alt="删除元素过程" /></p>

<p><strong>删除算法思路：</strong>
- 如果删除位置不合理，抛出异常；
- 取出删除元素；
- 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；
- 线性表长 -1.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 初始条件：顺序线性表L已存在，1≤i≤</span>
</span><span class="line"><span class="cm">   ListLength(L) */</span>
</span><span class="line"><span class="cm">/* 操作结果：删除 L 的第 i 个数据元素，并用 e 返回</span>
</span><span class="line"><span class="cm">   其值，L 的长度 -1 */</span>
</span><span class="line"><span class="n">Status</span> <span class="nf">ListDelete</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ElemType</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
</span><span class="line">    <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">    <span class="cm">/* 如果删除不是最后位置 */</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="cm">/* 将删除位置后继元素前移 */</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">L</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">--</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>线性表的顺序存储结构时间复杂度</strong>
- 在存和取数据元素时，在任何位置，时间复杂度都为 O(1)；
- 插入、删除时，（平均）时间复杂度为 O(n).</p>

<p><strong>顺序存储结构优缺点</strong>
- 优：可快速存取表中任一位置元素；
- 缺：插入、删除操作需移动大量元素；当线性表长度变化大时，无法确定存储空间容量；存储空间的浪费.</p>

<h2 id="section-7">四. 线性表的链式存储结构</h2>

<p>在顺序结构中，每个数据元素只需存数据元素的信息就可以了。而链式结构中需要存储两种数据 – <code>数据域</code>、<code>指针域</code>，两部分信息组成的数据元素，称为节点（Node）.</p>

<p><code>数据域</code>用来存储数据元素信息；
<code>指针域</code>用来存储直接后继地址.</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E5%8D%95%E9%93%BE%E8%A1%A8.png" alt="单链表" /></p>

<h3 id="section-8">4.1、头结点</h3>

<p><code>头结点</code>的数据域，可以不存储任何信息，也可以存储如线性表的长度等信息；头结点指针域存储第一个非空结点的地址，若线性表为空表，头结点指针域为 NULL。</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8.png" alt="带头结点的单链表" /></p>

<p><strong>C 语言创建<code>单链表</code>:</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 线性表的单链表存储结构 */</span>
</span><span class="line"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">	<span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
</span><span class="line">	<span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span> <span class="n">Node</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* 定义 LinkList */</span>
</span><span class="line"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">LinkList</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-9">4.2、最后一个结点</h3>

<p><code>最后一个结点</code>指针用 NULL 或 ‘^’ 表示。</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9.png" alt="最后一个结点" /></p>

<p>假设 <code>p</code> 是指向线性表第 i 个元素的<code>指针</code>，则该<code>结点 a(i)</code> 的数据域我们可以用 <code>p-&gt;data</code> 来表示，<code>p-&gt;data</code> 的值是一个数据元素，结点 <code>a(i)</code> 的指针域可以用 <code>p-&gt;next</code>来表示，<code>p-&gt;next</code> 的值是一个指针。如果 <code>p-&gt;data = a(i)</code>，那么 <code>p-&gt;next-&gt;data = a(i+1)</code></p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E5%85%B3%E7%B3%BB.png" alt="p-&gt;data, p-&gt;next-&gt;data" /></p>

<h2 id="section-10">五. 单链表</h2>

<h3 id="section-11">5.1、单链表的读取</h3>

<p>获取单链表第 i 个数据的算法思路：
- 声明一个<code>指针 p</code> 指向链表第一个结点，<code>初始化 j</code> 从 1 开始；
- 当 <code>j&lt;i</code> 时，就遍历链表，让 <code>p</code> 的指针向后移动，不断指向下一结点，<code>j</code> 累加 1；
- 若到链表末尾 <code>p</code> 为空，则说明<code>第 i 个结点</code>不存在；
- 否则查找成功，返回<code>结点 p</code> 的数据。</p>

<p>实现算法代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 初始条件：顺序线性表 L 已存在，1 ≤ i ≤ ListLength(L) */</span>
</span><span class="line"><span class="cm">/* 操作结果：用 e 返回 L 中第 i 个数据元素的值 */</span>
</span><span class="line"><span class="n">Status</span> <span class="nf">GetElem</span><span class="p">(</span><span class="n">LinkList</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ElemType</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class="line">	<span class="n">LinkList</span> <span class="n">p</span><span class="p">;</span>
</span><span class="line">	<span class="n">p</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">	<span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">	
</span><span class="line">	<span class="k">while</span><span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span>
</span><span class="line">	<span class="p">{</span>
</span><span class="line">		<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">		<span class="o">++</span><span class="n">j</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	
</span><span class="line">	<span class="cm">/* 第 i 个结点不存在 */</span>
</span><span class="line">	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">)</span>
</span><span class="line">		<span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
</span><span class="line">		
</span><span class="line">	<span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span><span class="line">	<span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面代码很容易理解，从头找到第 i 个结点为止。查找的时间复杂度为 O(n)。</p>

<h3 id="section-12">5.2、单链表的插入和删除</h3>

<h4 id="section-13">1)、单链表插入结点</h4>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9.png" alt="插入结点" /></p>

<p>实现思路如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line"><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>单链表插入结点</code>算法实现代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 初始条件：顺序线性表 L 已存在，1 ≤ i ≤ ListLength(L) */</span>
</span><span class="line"><span class="cm">/* 操作结果：在 L 中第 i 个结点位置之前插入新结点 e，L长度+1 */</span>
</span><span class="line"><span class="n">Status</span> <span class="nf">ListInsert</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ElemType</span> <span class="n">e</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class="line">	<span class="n">LinkList</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>
</span><span class="line">	<span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">L</span><span class="p">;</span>
</span><span class="line">	<span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">	
</span><span class="line">	<span class="cm">/* 寻找第 i - 1 个结点 */</span>
</span><span class="line">	<span class="k">while</span><span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span>
</span><span class="line">	<span class="p">{</span>
</span><span class="line">		<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">		<span class="o">++</span><span class="n">j</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	
</span><span class="line">	<span class="cm">/* 第 i 个结点不存在 */</span>
</span><span class="line">	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">)</span>
</span><span class="line">		<span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
</span><span class="line">	
</span><span class="line">	<span class="cm">/* 生成新结点（C 标准函数） */</span>
</span><span class="line">	<span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
</span><span class="line">	
</span><span class="line">	<span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
</span><span class="line">	<span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">	<span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class="line">	<span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <p><code>s = (LinkList)malloc(sizeof(Node));</code> 这里用到了 C 语言的 <code>malloc</code> 标准函数，实质上就是拿出一块空的内存，用来存放新的<code>结点 s</code>。</p>
</blockquote>

<h4 id="section-14">2)、单链表删除结点</h4>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.png" alt="删除结点" /></p>

<p><strong>实现思路如下：</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line"><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong><code>单链表删除结点</code>算法实现代码如下：</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 初始条件：顺序线性表 L 已存在，1 ≤ i ≤ ListLength(L) */</span>
</span><span class="line"><span class="cm">/* 操作结果：删除 L 的第 i 个结点，并用 e 返回其值，L 的长度 -1 */</span>
</span><span class="line"><span class="n">Status</span> <span class="nf">ListDelete</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ElemType</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class="line">	<span class="n">LinkList</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">;</span>
</span><span class="line">	<span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">L</span><span class="p">;</span>
</span><span class="line">	<span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">	
</span><span class="line">	<span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span>
</span><span class="line">	<span class="p">{</span>
</span><span class="line">		<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">		<span class="o">++</span><span class="n">j</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	
</span><span class="line">	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">)</span>
</span><span class="line">		<span class="k">return</span> <span class="n">ERROE</span><span class="p">;</span>
</span><span class="line">	
</span><span class="line">	<span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">	<span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">	<span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span><span class="line">	<span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
</span><span class="line">	
</span><span class="line">	<span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <p><code>free(q);</code>这里用到了 C 语言的标准函数 free，作用是释放一个结点的内存。</p>
</blockquote>

<p>在我们不知道第 <code>i</code> 个结点的指针位置时，假设我们从 <code>i</code> 位置，插入 <code>n</code> 个结点。顺序存储结构的时间复杂度为 <code>O(n^2)</code>，链式存储结构的时间复杂度为 <code>O(n)</code>。显然单链表数据结构插入和删除操作，比顺序存储结构效率要高。</p>

<h3 id="section-15">5.3、单链表的整表创建</h3>

<p>首先创建一个空的单链表，然后插入一个个新结点，新结点插入一般用两种方式 – <code>头插法</code>、<code>尾插法</code>。
- <code>头插法</code>：每次新结点都插在第一的位置；
- <code>尾插法</code>：每次新结点都插在终端结点的后面。</p>

<p><strong>头插法算法实现代码：</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 随机产生 n 个元素的值，建立表头结点的单链线性表 L（头插法） */</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">CreatListHead</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">	<span class="n">LinkList</span> <span class="n">p</span><span class="p">;</span>
</span><span class="line">	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">	
</span><span class="line">	<span class="cm">/* 初始化随机种子数 */</span>
</span><span class="line">	<span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span><span class="line">	
</span><span class="line">	<span class="o">*</span><span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
</span><span class="line">	
</span><span class="line">	<span class="cm">/* 创建一个带头结点的单链表 */</span>
</span><span class="line">	<span class="p">(</span><span class="o">*</span><span class="n">L</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">	
</span><span class="line">	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">	<span class="p">{</span>
</span><span class="line">		<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
</span><span class="line">		
</span><span class="line">		<span class="cm">/* 随机生成 100 以内的数 */</span>
</span><span class="line">		<span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">		<span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">L</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">		<span class="p">(</span><span class="o">*</span><span class="n">L</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>算法实现过程根据示意图很容易理解。上面代码中用到了 <code>srand(time(0))</code>，这里的目的是初始化一个随机数种子。实质上就是后面每次 <code>rand()</code> 时，不同时刻可以拿到不同的数，这个数就是 1970.1.1 至今的秒数。这样就能确保每次我们拿到的都是不同的数字。</p>

<p><strong>尾插法算法实现代码：</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 随机产生 n 个元素的值，建立带表头结点的单链表 L（尾插法） */</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">CreatListTail</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">	<span class="n">LinkList</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
</span><span class="line">	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">	
</span><span class="line">	<span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span><span class="line">	<span class="o">*</span><span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
</span><span class="line">	<span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">L</span><span class="p">;</span>
</span><span class="line">	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">	<span class="p">{</span>
</span><span class="line">		<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
</span><span class="line">		<span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">		<span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span><span class="line">		<span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	
</span><span class="line">	<span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>了解头插法后看尾插法应该很容易理解了。</p>

<h3 id="section-16">5.4、单链表的整表删除</h3>

<p>算法实现代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 初始条件：单链表 L 已存在 */</span>
</span><span class="line"><span class="cm">/* 操作结果：将 L 重置为空表 */</span>
</span><span class="line"><span class="n">Status</span> <span class="nf">ClearList</span><span class="p">(</span><span class="n">LinkList</span> <span class="o">*</span><span class="n">L</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">	<span class="n">LinkList</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">;</span>
</span><span class="line">	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">L</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">	
</span><span class="line">	<span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span><span class="line">	<span class="p">{</span>
</span><span class="line">		<span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">		<span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">		<span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	
</span><span class="line">	<span class="p">(</span><span class="o">*</span><span class="n">L</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">	<span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-17">5.5、单链表结构与顺序结构对比</h3>

<ul>
  <li>若线性表需要频繁查找，很少进行插入删除操作，宜采用<code>顺序存储结构</code>。若需要频繁插入删除，宜采用<code>单链表结构</code>。如游戏开发中，对于用户注册的个人信息，注册时插入数据后绝大多数只是读取，可以考虑用顺序存储结构；而游戏中玩家的武器装备列表，随着玩家的游戏进度，可能会随时增加或删除，单链表结构更合适。这里是简单类比，实际考虑的会更多。</li>
  <li>当线性表中的元素个数变化较大或者不确定元素个数，最好用<code>单链表结构</code>，这样不需要考虑存储空间大小问题。如果知道线性表大致长度（像一年 12 月，一周 7 天…），这时<code>顺序存储结构</code>效率会高很多。</li>
</ul>

<h2 id="section-18">六. 静态链表</h2>

<p>对于C 语言，它具有指针能力，使得它可以方便地操作内存中的地址和数据；对于 Objective - C 之类面向对象的语言，因为他们有对象引用机制，间接实现了指针的一些作用；但对于一些早期的编程高级语言（Basic 等），它们没有指针，按前面的方法链表结构就无法实现了。但方法总是会有的，就诞生了静态链表。</p>

<h3 id="section-19">6.1、什么是静态链表？</h3>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A81.png" alt="静态链表" /></p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A82.png" alt="静态链表" /></p>

<p>首先我们让数组的元素都是由两个数据域组成，<code>data</code>和<code>cur</code>。也就是说，数组的每一个下标都对应一个<code>data</code>和一个<code>cur</code>。
数据域<code>data</code>用来存放数据元素，也就是通常我们要处理的数据；而游标<code>cur</code>相当于单链表中的<code>next</code>指针，存放该元素的后继在数组中的下标。我们把这种用数组描述的链表叫做<code>静态链表</code>。
数组的第一个元素，即下标为 0 的元素的 <code>cur</code> 就存放备用链表的第一个结点的下标；而数组的最后一个元素的 <code>cur</code> 则存放第一个有数值的元素的下标，相当于单链表的头节点作用，当整个链表为空时，则为 <code>0</code>，表示无指向。</p>

<p>初始化代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 线性表的静态链表存储结构 */</span>
</span><span class="line"> <span class="cp">#define MAXSIZE 1000                     </span>
</span><span class="line"> <span class="k">typedef</span> <span class="k">struct</span>
</span><span class="line"> <span class="p">{</span>
</span><span class="line">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span>
</span><span class="line"> <span class="p">}</span> <span class="n">StaticLinkList</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"> <span class="cm">/* 将一维数组space中各分量链成一备用链表， */</span>
</span><span class="line"> <span class="cm">/* space[0].cur为头指针，&quot;0&quot;表示空指针 */</span>
</span><span class="line"> <span class="n">Status</span> <span class="nf">InitList</span><span class="p">(</span><span class="n">StaticLinkList</span> <span class="n">space</span><span class="p">)</span>
</span><span class="line"> <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAXSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">space</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="cm">/* 目前静态链表为空，最后一个元素的cur为0 */</span>
</span><span class="line">    <span class="n">space</span><span class="p">[</span><span class="n">MAXSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">	<span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span><span class="line"> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-20">6.2、静态链表的插入操作</h3>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.png" alt="静态链表的插入操作" /></p>

<p>在动态链表中，结点的申请和释放分别借用<code>malloc()</code>和<code>free()</code>两个函数来实现。在静态链表中，操作的是数组，不存在像动态链表的结点申请和释放问题，所以我们需要自己实现这两个函数，才可以做插入和删除的操作。
为辨明数组中哪些分量未被使用，将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。如下代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 若备用空间链表非空，则返回分配的结点下标，否则返回0 */</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">Malloc_SLL</span><span class="p">(</span><span class="n">StaticLinkList</span> <span class="n">space</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="cm">/* 当前数组第一个元素的cur存的值，就是要返回的第一个备用空闲的下标 */</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
</span><span class="line">	
</span><span class="line">    <span class="cm">/* 由于要拿出一个分量来使用了，所以我们就得把它的下一个分量用来做备用 */</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cur</span><span class="p">)</span>
</span><span class="line">		<span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">space</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* 在L中第i个元素之前插入新的数据元素e  */</span>
</span><span class="line"><span class="n">Status</span> <span class="nf">ListInsert</span><span class="p">(</span><span class="n">StaticLinkList</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ElemType</span> <span class="n">e</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">;</span>
</span><span class="line">    <span class="cm">/* 注意 k 是最后一个元素的下标 */</span>
</span><span class="line">    <span class="n">k</span> <span class="o">=</span> <span class="n">MAX_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">ListLength</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
</span><span class="line">		
</span><span class="line">    <span class="cm">/* 获得空闲分量的下标 */</span>
</span><span class="line">    <span class="n">j</span> <span class="o">=</span> <span class="n">Malloc_SSL</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">       <span class="cm">/* 将数据赋值给此分量的 data */</span>
</span><span class="line">       <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">data</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
</span><span class="line">       <span class="cm">/* 找到第i个元素之前的位置 */</span>
</span><span class="line">       <span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">           <span class="n">k</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
</span><span class="line">       <span class="cm">/* 把第i个元素之前的cur赋值给新元素的cur */</span>
</span><span class="line">       <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
</span><span class="line">       <span class="cm">/* 把新元素的下标赋值给第i个元素之前元素的cur */</span>
</span><span class="line">       <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span><span class="line">       <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span><span class="line">	 <span class="p">}</span>
</span><span class="line">
</span><span class="line">	 <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-21">6.3、静态链表的删除操作</h3>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.png" alt="静态链表的删除操作" /></p>

<p>和插入操作原理相同，删除操作代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 删除在 L 中第 i 个数据元素 e */</span>
</span><span class="line"><span class="n">Status</span> <span class="nf">ListDelete</span><span class="p">(</span><span class="n">StaticLinkList</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">ListLength</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
</span><span class="line">    <span class="n">k</span> <span class="o">=</span> <span class="n">MAX_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">k</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
</span><span class="line">    <span class="n">j</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
</span><span class="line">    <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
</span><span class="line">    <span class="n">Free_SSL</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* 将下标为k的空闲结点回收到备用链表 */</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">Free_SSL</span><span class="p">(</span><span class="n">StaticLinkList</span> <span class="n">space</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="cm">/* 把第一个元素 cur 值赋给要删除的分量 cur */</span>
</span><span class="line">    <span class="n">space</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
</span><span class="line">    <span class="cm">/* 把要删除的分量下标赋值给第一个元素的 cur */</span>
</span><span class="line">	<span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* 初始条件：静态链表 L 已存在。操作结果：返回 L 中数据元素个数 */</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">ListLength</span><span class="p">(</span><span class="n">StaticLinkList</span> <span class="n">L</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">MAXSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">i</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
</span><span class="line">        <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">	
</span><span class="line">	<span class="k">return</span> <span class="n">j</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-22">6.4、静态链表优缺点</h3>

<ul>
  <li>优点：在插入删除操作时，只需要修改游标，不需要移动元素；</li>
  <li>缺点：失去顺序存储结构随机存取的特性，存储需要的表长难以确定。</li>
</ul>

<p>静态链表给没有指针的高级语言设计了一种实现单链表能力的方法，实际中不一定用到，但这个是思想很赞的。</p>

<h2 id="section-23">七. 循环链表</h2>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E7%A9%BA%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="空循环链表" /></p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E9%9D%9E%E7%A9%BA%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="非空循环链表" /></p>

<p>将单链表中<code>终端结点</code>的指针由空指针指向<code>头结点</code>，使单链表形成一个环，这种头尾相连的单链表称为<code>单循环链表</code>，简称<code>循环链表</code>。</p>

<p>循环链表中，从任何一个结点出发，可以访问到链表的全部结点。</p>

<p>在当循环列表中，访问第一个结点的时间复杂度是 O(1)；而访问最后一个结点的时间复杂度是 O(n)。那有没有可能，用 O(1) 时间访问到最后一个节点呢？
这里我们改造下循环链表，用指向最后一个结点的尾指针，不用头指针，就可以很方便的查找头结点和尾结点了。</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E5%B0%BE%E6%8C%87%E9%92%88.png" alt="尾指针" /></p>

<p>尾指针有什么方便之处呢？看下下面这两个链表的合并。</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E5%90%88%E5%B9%B6%E4%B8%A4%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%20-%20%E5%89%8D.png" alt="合并两循环链表 - 前" /></p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E5%90%88%E5%B9%B6%E4%B8%A4%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%20-%20%E5%90%8E.png" alt="合并两循环链表 - 后" /></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 保存A表的头结点，即① */</span>
</span><span class="line"><span class="n">p</span> <span class="o">=</span> <span class="n">rearA</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/*将本是指向B表的第一个结点（不是头结点） */</span>
</span><span class="line"><span class="n">rearA</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">rearB</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* 赋值给reaA-&gt;next，即② */</span>
</span><span class="line"><span class="n">q</span> <span class="o">=</span> <span class="n">rearB</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* 将原A表的头结点赋值给rearB-&gt;next，即③ */</span>
</span><span class="line"><span class="n">rearB</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* 释放 q */</span>
</span><span class="line"><span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-24">八. 双向链表</h2>

<p>双向链表中结点拥有两个指针域，一个指向直接前驱，一个指向直接后继。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 线性表的双向链表存储结构 */</span>
</span><span class="line"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">DulNode</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">DuLNode</span> <span class="o">*</span><span class="n">prior</span><span class="p">;</span>    <span class="cm">/* 直接前驱指针 */</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">DuLNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>     <span class="cm">/* 直接后继指针 */</span>
</span><span class="line"><span class="p">}</span> <span class="n">DulNode</span><span class="p">,</span> <span class="o">*</span><span class="n">DuLinkList</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E7%A9%BA%E9%93%BE%E8%A1%A8.png" alt="双向链表的循环带头结点的空链表" /></p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E9%9D%9E%E7%A9%BA%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="非空的循环的带头结点的双向链表" /></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 链表中的某一结点 p */</span>
</span><span class="line"><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prior</span> <span class="o">=</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prior</span><span class="o">-&gt;</span><span class="n">next</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>假设存储元素 e 的结点 s，要实现将结点 s 插入到结点 p 和 p-&gt;next 之间，如下：</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E7%BB%93%E7%82%B9%E6%8F%92%E5%85%A5.png" alt="结点插入" /></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 把p赋值给s的前驱，如图中① */</span>
</span><span class="line"><span class="n">s</span><span class="o">-&gt;</span><span class="n">prior</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* 把p-&gt;next赋值给s的后继，如图中② */</span>
</span><span class="line"><span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* 把s赋值给p-&gt;next的前驱，如图中③ */</span>
</span><span class="line"><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prior</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* 把s赋值给p的后继，如图中④ */</span>
</span><span class="line"><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>理解了插入操作，删除操作就比较简单了，示意图如下：</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_003%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%20p.png" alt="删除结点 p" /></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* 把p-&gt;next赋值给p-&gt;prior的后继，如图中① */</span>
</span><span class="line"><span class="n">p</span><span class="o">-&gt;</span><span class="n">prior</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* 把p-&gt;prior赋值给p-&gt;next的前驱，如图中② */</span>
</span><span class="line"><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prior</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prior</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* 释放结点 */</span>
</span><span class="line"><span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <p><strong>本篇参考：</strong>
<br /><br />
<a href="http://book.douban.com/subject/6424904/">大话数据结构</a></p>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构浅析（二）：算法]]></title>
    <link href="http://jonyfang.com/blog/2016/01/02/data_structure02.algorithm/"/>
    <updated>2016-01-02T18:01:00+08:00</updated>
    <id>http://jonyfang.com/blog/2016/01/02/data_structure02.algorithm</id>
    <content type="html"><![CDATA[<p class="info">我们常常会看到<a href="http://www.douban.com/search?cat=1001&amp;q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95">《数据结构与算法》</a>之类的书，那么数据结构和算法为什么会在一起呢？通过上一篇 <a href="http://jonyfang.com/blog/2015/12/25/the_basic_conception_in_data_structure/">数据结构基本概念</a> 我们知道，数据结构是互相之间存在一种或多种特定关系的数据元素的集合。这里的 <code>一种或多种特定关系</code>的处理就涉及到算法，所以对于完整的程序设计 <code>数据结构</code> 和 <code>算法</code> 都很重要。</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">一. 什么是算法？</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">二. 算法的特征</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">三. 算法设计的要求</a>    <ul>
      <li><a href="#section-3" id="markdown-toc-section-3">3.1、正确性</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">3.2、可读性</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">3.3、健壮性</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">3.4、时间效率高和存储量低</a></li>
    </ul>
  </li>
  <li><a href="#section-7" id="markdown-toc-section-7">四. 算法时间复杂度</a>    <ul>
      <li><a href="#section-8" id="markdown-toc-section-8">4.1、什么是算法时间复杂度？</a></li>
      <li><a href="#section-9" id="markdown-toc-section-9">4.2、怎么分析出算法的时间复杂度？</a></li>
      <li><a href="#section-10" id="markdown-toc-section-10">4.3、常数阶</a></li>
      <li><a href="#section-11" id="markdown-toc-section-11">4.4、线性阶</a></li>
      <li><a href="#section-12" id="markdown-toc-section-12">4.5、对数阶</a></li>
      <li><a href="#section-13" id="markdown-toc-section-13">4.6、平方阶</a></li>
      <li><a href="#section-14" id="markdown-toc-section-14">4.7、常见时间复杂度</a></li>
    </ul>
  </li>
  <li><a href="#section-15" id="markdown-toc-section-15">五. 算法空间复杂度</a></li>
  <li><a href="#section-16" id="markdown-toc-section-16">六. 总结</a></li>
</ul>

<!-- more -->

<p>本篇主要介绍算法的一些概念内容，方便后面的数据结构学习。</p>

<h2 id="section">一. 什么是算法？</h2>
<p><a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95">算法（Algorithm）</a> 英文词最早是由 9 世纪 <a href="https://zh.wikipedia.org/wiki/%E8%8A%B1%E6%8B%89%E5%AD%90%E7%B1%B3">波斯数学家花拉子米</a> 提出，<a href="https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95">欧几里得算法</a>被人们认为是史上第一个算法。如今普遍对算法的定义是：算法是决定特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p>

<p>简而言之也就是为了解决某个或某类问题，需要把指令表示成一定的操作序列，操作序列包括一组操作，每一个操作都完成特定的功能，这就是算法了。</p>

<h2 id="section-1">二. 算法的特征</h2>

<p>算法具有五个基本特征：<code>输入</code>、<code>输出</code>、<code>有穷性</code>、<code>确定性</code>、<code>可行性</code></p>

<p>前面三个从字面很容易理解，简单说下后面两个；
<strong><code>确定性</code></strong> 指算法在一定确定条件下，相同的输入只可能有唯一的输出结果；
<strong><code>可行性</code></strong> 指算法的每一步都可以通过执行有限次数完成。</p>

<h2 id="section-2">三. 算法设计的要求</h2>

<p>好算法的基本要求有：<code>正确性</code>、<code>可读性</code>、<code>健壮性</code>、<code>时间效率高和存储量低</code></p>

<h3 id="section-3">3.1、正确性</h3>

<p>算法的正确性指算法至少具有输入、输出、加工处理无歧义、能正确反映问题需求、能得倒问题的正确答案。
具体到程序大体分为下面 4 个层次：
- 算法程序没有语法错误；
- 算法程序对于合法的输入数据能够产生满足要求的输出结果；
- 算法程序对于非法的输入数据能够得出满足规格说明的结果；
- 算法程序对于极端的测试数据都有满足要求的输出结果。</p>

<p>证明一个复杂算法正确性代价很高，很难通过程序证明，一般采用数学方法证明，满足前 3 个层次就可以说是一个合格的算法了。</p>

<h3 id="section-4">3.2、可读性</h3>

<p>程序设计很多时候不是一个人搞定的，便于阅读理解还是很重要的。</p>

<h3 id="section-5">3.3、健壮性</h3>

<p>当输入数据不合法时，算法能做出相关处理，而不是产生异常或莫名其妙的结果，那么这就是健壮的算法。</p>

<h3 id="section-6">3.4、时间效率高和存储量低</h3>

<p>时间效率高是相对的。对于同一个问题，如果有多个算法可以解决，执行时间短的就是效率高的；</p>

<p>存储量指的是算法在执行过程中需要的最大内存和外部硬盘存储空间。我们生活中中希望花最少的钞票、最少的时间办最大的事，算法也是如此。</p>

<h2 id="section-7">四. 算法时间复杂度</h2>

<h3 id="section-8">4.1、什么是算法时间复杂度？</h3>

<p><code>算法时间复杂度</code>，是算法的时间量度，记作：T ( n ) = O ( f ( n ) )</p>

<p>n 表示问题规模；T ( n ) 表示语句总的执行次数；f ( n ) 是问题规模 n 的某个函数；大 O ( ) 用来记录<code>算法时间复杂度</code>，如我们常见的 O ( 1 )、O ( n ) 、O ( n^2 ) ….</p>

<p>一般情况下，随着 n 的增大， T ( n ) 增长最慢的算法为<code>最优算法</code>。</p>

<h3 id="section-9">4.2、怎么分析出算法的时间复杂度？</h3>

<p>如何分析出一个算法的时间复杂度呢？这里有个分析时间复杂度的<code>推导方法</code>：
- 用常数 1 取代运行时间中的所有加法常数；
- 在修改后的运行次数函数中，只保留最高阶项；
- 如最高阶项存在且不是 1 ，则去除与这个项相乘的常数。</p>

<p>下面分析一些简单的算法时间复杂度。</p>

<h3 id="section-10">4.3、常数阶</h3>

<p>例如：求 1+2+3+…+100 和
我们很容易想到的是 <code>高斯算法</code>，如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>         <span class="cm">/* 执行一次 */</span>
</span><span class="line"><span class="n">sum</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>        <span class="cm">/* 执行一次 */</span>
</span><span class="line"><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>            <span class="cm">/* 执行一次 */</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>由  <code>T ( n ) = O ( f ( n ) )</code>，找到依次数据，很容易得到 <code>f ( n ) = 3</code>；根据上面给出的推到方法，我们很容易得出 <code>高斯算法</code> 的时间复杂度为<code>O (1)</code></p>

<h3 id="section-11">4.4、线性阶</h3>

<p>举个例子，如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="cm">/* 时间复杂度为 O (1) 的程序步骤序列 */</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>循环体中的代码需要执行 <code>n 次</code>，即 <code>f( n ) = n</code>，所以它的时间复杂度为 <code>O( n )</code></p>

<h3 id="section-12">4.5、对数阶</h3>

<p>举例如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>每次 count * 2 之后，就距离 n 更近一分。那么有多少个 2 相乘后大于 n 退出循环？ 数学表示来看也就是 2^x = n ，得到 x = log(2 为底 n 的对数） [<code>markdown</code> 写数学公式功底不够，理解就好…]，得出 T( n ) = logn;</p>

<h3 id="section-13">4.6、平方阶</h3>

<p><strong>下面是一个<code>循环嵌套</code>例子：</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="cm">/* 时间复杂度为 O(1) 的程序步骤序列 */</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>外层</code>和<code>内层</code>的时间复杂度都是 <code>O(n)</code>，所以这段代码的时间复杂度是 <code>O(n^2)</code>.</p>

<p><strong>再看下面一个<code>循环嵌套</code>例子：</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="cm">/* 时间复杂度为 O(1) 的程序步骤序列 */</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>外层和内层的时间复杂度依次为 <code>O(m)</code>, <code>O(n)</code>，所以这段代码的时间复杂度是 <code>O(m * n)</code></p>

<p><strong>接着再看一个例子：</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">   <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="cm">/* 时间复杂度为 O(1) 的程序步骤序列*/</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当 i = 0 时，内循环执行 n 次；当 i = 1 时，内循环执行 n-1 次；……；当 i = n -1时，执行 1 次。所以总的执行次数为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">n</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">...</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="n">n</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">=</span> <span class="n">n</span><span class="o">^</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>根据前面的<code>推导方法</code>，很容易得到这段代码的<code>时间复杂度</code>为 <code>O(n^2)</code>.</p>

<h3 id="section-14">4.7、常见时间复杂度</h3>

<p>常见时间复杂度如表：</p>

<table>
  <thead>
    <tr>
      <th>执行次数</th>
      <th>函数阶</th>
      <th>非正式术语</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>12</td>
      <td>O(1)</td>
      <td>常数阶</td>
    </tr>
    <tr>
      <td>2n + 3</td>
      <td>O(n)</td>
      <td>线性阶</td>
    </tr>
    <tr>
      <td>3n^2 + 2n + 1</td>
      <td>O(n^2)</td>
      <td>平方阶</td>
    </tr>
    <tr>
      <td>6n^3 + 2n^2 + 3n +4</td>
      <td>O(n^3)</td>
      <td>立方阶</td>
    </tr>
    <tr>
      <td>5log2n + 20</td>
      <td>O(logn)</td>
      <td>对数阶</td>
    </tr>
    <tr>
      <td>2n + 3nlog2n + 19</td>
      <td>O(nlogn)</td>
      <td>nlogn 阶</td>
    </tr>
    <tr>
      <td>2^n</td>
      <td>O(2^n)</td>
      <td>指数阶</td>
    </tr>
  </tbody>
</table>

<p>常用时间复杂度所消耗时间从小到大依次为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"> <span class="n">O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">O</span><span class="p">(</span><span class="n">logn</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">O</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">O</span><span class="p">(</span><span class="n">nlogn</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">O</span><span class="p">(</span><span class="n">n</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">O</span><span class="p">(</span><span class="n">n</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">O</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">O</span><span class="p">(</span><span class="n">n</span><span class="o">!</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">O</span><span class="p">(</span><span class="n">n</span><span class="o">^</span><span class="n">n</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"> <span class="cp"># 其中的 指数阶 和 阶乘阶 很少用到，你懂的...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-15">五. 算法空间复杂度</h2>

<p>算法的<code>空间复杂度</code>通过计算算法所需的存储空间实现，计算公式： <code>S(n) = O( f( n ) )</code>，<code>n</code> 为问题的规模，<code>f(n)</code> 为语句关于 <code>n</code> 所占存储空间的函数。</p>

<p>通常，我们使用<code>时间复杂度</code>来指运行时间的需求，用<code>空间复杂度</code>指空间需求。</p>

<h2 id="section-16">六. 总结</h2>

<p>本篇提到的<code>算法时间复杂度</code>用处还是挺多的，后面自己写程序过程中也尽可能得降低时间复杂度。</p>

<blockquote>
  <p><strong>本篇参考：</strong>
<br /><br />
<a href="http://book.douban.com/subject/6424904/">大话数据结构</a>
<br />
<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95">Wikipedia - 算法（Algorithm）</a></p>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构浅析（一）：数据结构基本概念]]></title>
    <link href="http://jonyfang.com/blog/2015/12/25/data_structure01.the_basic_conception_in_data_structure/"/>
    <updated>2015-12-25T22:01:00+08:00</updated>
    <id>http://jonyfang.com/blog/2015/12/25/data_structure01.the_basic_conception_in_data_structure</id>
    <content type="html"><![CDATA[<p class="info"><strong>首先会有个疑问，什么是数据结构呢？</strong>
<br />
数据结构（data structure），可以概括为是互相之间存在一种或多种特定关系的数据元素的集合。开篇配图来自网络…</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">一、数据结构起源</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">二、基本概念和术语</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">2.1、数据</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">2.2、数据元素</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">2.3、数据项</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">2.4、数据对象</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">2.5、数据结构</a></li>
    </ul>
  </li>
  <li><a href="#section-7" id="markdown-toc-section-7">三、逻辑结构和物理结构</a>    <ul>
      <li><a href="#section-8" id="markdown-toc-section-8">3.1、逻辑结构</a></li>
      <li><a href="#section-9" id="markdown-toc-section-9">3.2、物理结构</a></li>
    </ul>
  </li>
  <li><a href="#section-10" id="markdown-toc-section-10">四、抽象数据类型</a>    <ul>
      <li><a href="#section-11" id="markdown-toc-section-11">4.1、数据类型是什么？</a></li>
      <li><a href="#section-12" id="markdown-toc-section-12">4.2、抽象数据类型</a></li>
    </ul>
  </li>
  <li><a href="#section-13" id="markdown-toc-section-13">五、总结</a></li>
</ul>

<!-- more -->

<h2 id="section">一、数据结构起源</h2>

<p>1968年，美国 Donald E. Knuth 教授在《计算机程序设计艺术》第一卷《基本算法》中系统阐述了数据的逻辑结构和存储结构及其操作，开创了数据结构课程体系。</p>

<p>70年代初，大型程序相继出现，软件也开始相对独立，结构程序设计成为程序设计方法学主要内容，人们开始认为程序设计的实质是对确定的问题选择一种好的结构，加上设计一种好的算法。也就是 <strong>程序设计 = 数据结构 + 算法</strong></p>

<p>现实生活中，更多的不是解决一些数值计算问题，我们需要通过表、树、图等数据结构的帮助来更好地处理问题。</p>

<p>所以数据结构也是一门研究非数字计算的程序设计问题中的操作对象，以及他们之间的关系和操作等相关问题的学科。（引用自<a href="http://book.douban.com/subject/6424904/">《大话数据结构》</a>）</p>

<h2 id="section-1">二、基本概念和术语</h2>

<h3 id="section-2">2.1、数据</h3>

<ul>
  <li>数据指的是能输入到计算机中，并能被计算机程序处理的对象。</li>
  <li>对于数值类型（整型、实型等），可以进行数值计算；
对于字符数据类型（声音、图像、视频等可通过编码转化为字符数据），可以进行非数值处理。</li>
</ul>

<h3 id="section-3">2.2、数据元素</h3>

<ul>
  <li>数据元素指组成数据的、有意义的基本单位，也被称为记录。</li>
  <li>如：一部电影里面的女主就是数据元素</li>
</ul>

<h3 id="section-4">2.3、数据项</h3>

<ul>
  <li>数据项是数据不可分割的最小单位，一个数据元素可以由若干数据项组成。</li>
  <li>如：一部电影里面女主的姓名、性别等都是数据项，恩，女主性别一般是女…</li>
</ul>

<h3 id="section-5">2.4、数据对象</h3>

<ul>
  <li>数据对象指性质相同的数据元素的集合，是数据的子集；</li>
  <li>数据对象简称数据
什么是性质相同呢？
性质相同指数据元素具有相同数量和类型的数据项；
如一部电影中每个角色（数据元素）都有姓名、性别（数据项），这些角色（数据元素）构成了一部电影，那么这部电影所有人物的集合我们可以想象成是一个数据对象。</li>
</ul>

<h3 id="section-6">2.5、数据结构</h3>

<ul>
  <li>数据结构指互相之间存在一种或多种特定关系的数据元素的集合；</li>
  <li>数据结构 = 数据元素 + 关系；
还得用上面的例子，一部电影可以想象成是一个数据结构，是由一个个人物（数据元素）和一个个串联的人物情节（关系）构成，例子有点勉强，大概意思都应该理解的…</li>
</ul>

<h2 id="section-7">三、逻辑结构和物理结构</h2>

<h3 id="section-8">3.1、逻辑结构</h3>

<ul>
  <li>逻辑结构指数据对象中数据元素之间的相互关系；</li>
  <li>逻辑结构分为 集合结构、线性结构、树形结构 和 图形结构；</li>
</ul>

<p>1). 集合结构：其中的数据元素除同属于一个集合外，之间没有其他关系；</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_01%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84.jpg" alt="集合结构" /></p>

<p>2). 线性结构：其中的数据元素之间是一对一的关系；</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_01%E7%BA%BF%E5%9E%8B%E7%BB%93%E6%9E%84.jpg" alt="线性结构" /></p>

<p>3). 树形结构：其中的数据元素之间存在一对多的层次关系；</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_01%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.jpg" alt="树形结构" /></p>

<p>4). 图形结构：其中的数据元素之间存在多对多的关系。</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_01%E5%9B%BE%E5%BD%A2%E7%BB%93%E6%9E%84.jpg" alt="图形结构" /></p>

<h3 id="section-9">3.2、物理结构</h3>

<ul>
  <li>物理结构指数据的逻辑结构在计算机中的存储形式；</li>
  <li>实际就是如何将数据元素存储到计算机存储器中。这里的存储器主要针对内存而言，像硬盘等外部存储器的数据组织通常使用文件结构来描述；</li>
  <li>数据元素的存储结构形式有 顺序存储 和 链式存储 两种；</li>
</ul>

<p>1).顺序存储结构</p>

<p>顺序存储结构：把数据元素存放在地址连续的的存储单元里，其数据间的逻辑关系和物理关系一致；</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_01%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg" alt="顺序存储结构" /></p>

<p>2).链式存储结构</p>

<p>链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的也可以是不连续的。数据元素的存储关系不反映其逻辑关系，用指针存放数据元素的地址，我们通过地址可以找到相关联数据元素的位置。</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_01%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg" alt="链式存储结构" /></p>

<ul>
  <li>两种物理结构对比来看，链式存储更为灵活</li>
</ul>

<p class="info">逻辑结构面向问题，物理结构面向计算机，其基本目标是将数据及其逻辑关系存储到计算机的内存中。</p>

<h2 id="section-10">四、抽象数据类型</h2>

<h3 id="section-11">4.1、数据类型是什么？</h3>

<p>数据类型指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p>

<p>看起来有点模糊，接着往下看。</p>

<p>数据类型按照值的不同进行划分。在高级语言中，每个变量、常量、表达式都有各自取值范围。类型就用来说明变量或表达式的取值范围和所进行的操作。</p>

<p>计算机的内存是有限的，如果只是单纯计算 1+1 =2这样的整型数字运算，我们不需要开辟很大的内存空间，只要满足相应需求的内存空间就可以了。于是计算机领域的前辈们对数据进行分类，不同的数据类型拥有各自的取值范围。这样就可以更好利用有限的内存空间。</p>

<p>例如 C 语言中，数据类型可以分两类：
- 原子类型：不可再分割的基本类型。如整型、实型、字符型等基本数据类型；
- 结构类型：由若干类型组成，可再分解。如整型数组就是由若干整型数据组成的。</p>

<h3 id="section-12">4.2、抽象数据类型</h3>

<p><strong>1). 上面解释了什么是数据类型，那么为什么要把数据类型抽象出来呢？</strong></p>

<p>不同的计算机有不同的硬件系统，所以需要程序语言最终通过编译器或解释器转化成计算机能够识别的底层语言。然而在我们使用高级语言开发时，如计算 1+1 ，不管最终程序运行在什么计算机上，我们的目的只是为了实现 2 个整型数字的运算，不需要详细知道 CPU 为了实现 1+1 进行了几次开关操作。但无论什么计算机、什么计算机语言都会面临如整数运算这样的操作，那么可以考虑把它们抽象出来，只保留实现目标所必需的信息。</p>

<p><strong>2). 什么是抽象数据类型？</strong></p>

<p><strong>抽象数据类型（Abstract Data Type, ADT）</strong>:指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于他的一组逻辑特性，与其在计算机内部如何表示和实现无关。</p>

<p><strong>3). 抽象数据类型有什么意义？</strong></p>

<p>“抽象”的意义在于数据类型的数学抽象特性。一个抽象数据类型定义了一个数据对象、数据对象中各数据元素之间的关系及对数据元素的操作。</p>

<p>理论的东西说起来总是那么模糊，看一个例子就会发现清晰明了了。</p>

<p>还是之前整数计算的例子。计算机分很多种，大型机、小型机、PC、智能手机等等，但是任何一种都有“整型数据”，也都需要进行“整型数据”运算。那么这里的整型其实就是一个抽象数据类型，它在不同计算机内的实现方法可能不同，但定义的数学特性相同，所以在我们看来是相同的。</p>

<p class="info">抽象数据类型理论的东西提的比较多，概括下也就是为什么会有各种不同的数据类型，同时解释这些数据类型存在的意义是什么…</p>

<h2 id="section-13">五、总结</h2>

<p>直接上图吧，一图胜千言…</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%B1%82%E6%AC%A1.jpg" alt="数据结构层次" /></p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/data_structure_01%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84.jpg" alt="逻辑结构与物理结构" /></p>

<blockquote>
  <p><strong>本文参考：</strong>
<br /><br />
<strong><a href="http://book.douban.com/subject/6424904/">《大话数据结构》</a></strong>
<br /><br />
<strong><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E5%BE%B7%E7%BA%B3">Wikipedia - Donald E. Knuth</a></strong></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从 Github 恢复 Octopress 到本地]]></title>
    <link href="http://jonyfang.com/blog/2015/12/07/recover_your_local_octopress_repository/"/>
    <updated>2015-12-07T20:08:00+08:00</updated>
    <id>http://jonyfang.com/blog/2015/12/07/recover_your_local_octopress_repository</id>
    <content type="html"><![CDATA[<p class="info">当遇到自己换到一台新的电脑，或本地的 octopress 环境出现了问题，我们都可以从 Github 恢复 Octopress 到本地，在了解了之前的部署操作后这里就很简单了的,进入正题吧。
<br />
(附部署操作：<a href="http://jonyfang.com/blog/2015/10/16/starting_blog_with_octopress_2/">基于 Octopress &amp; Github Pages 搭建博客（二）</a>)</p>
<!-- more -->

<p>Github 远程目录有两个分支，一个<strong><code>master</code></strong>，一个 <strong><code>source</code></strong>，首先把 <code>source</code> 分支 <code>clone</code> 下来:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"><span class="err">$</span> <span class="n">git</span> <span class="nb">clone</span> <span class="o">-</span><span class="n">b</span> <span class="n">source</span> <span class="n">git</span><span class="vi">@github</span><span class="o">.</span><span class="n">com</span><span class="ss">:username</span><span class="o">/</span><span class="n">username</span><span class="o">.</span><span class="n">github</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">git</span> <span class="n">octopress</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>进入 octopress 目录，安装 Octopress 所需要的依赖库（dependencies）：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"><span class="err">$</span> <span class="n">cd</span> <span class="n">octopress</span>
</span><span class="line"><span class="err">$</span> <span class="n">gem</span> <span class="n">install</span> <span class="n">bundler</span>
</span><span class="line"><span class="err">$</span> <span class="n">bundle</span> <span class="n">install</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>接着执行如下命令，提示后，输入 Github 仓库的 URL （例如：git@github.com:username/username.github.io.git）：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"><span class="err">$</span> <span class="n">rake</span> <span class="n">setup_github_pages</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后删除生成的 <code>_deploy</code>，克隆 <code>master</code> 分支到本地：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"><span class="err">$</span> <span class="n">rm</span> <span class="o">-</span><span class="n">rf</span> <span class="n">_deploy</span>
</span><span class="line"><span class="err">$</span> <span class="n">git</span> <span class="nb">clone</span> <span class="n">git</span><span class="vi">@github</span><span class="o">.</span><span class="n">com</span><span class="ss">:username</span><span class="o">/</span><span class="n">username</span><span class="o">.</span><span class="n">github</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">git</span> <span class="n">_deploy</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 常用命令和 Git Flow 梳理]]></title>
    <link href="http://jonyfang.com/blog/2015/11/12/git_command_and_git_branching_model/"/>
    <updated>2015-11-12T00:30:00+08:00</updated>
    <id>http://jonyfang.com/blog/2015/11/12/git_command_and_git_branching_model</id>
    <content type="html"><![CDATA[<p class="info">用 git 有一段时间了，之前没有详细地了解 git flow，导致协作过程中或多或少出现了一些头疼问题。最近静下心来理了下 git flow 的整个流程，再回头看开朗了不少，总结到这里。介绍的是一些常用的 git 基础命令和 git flow，当然也很重要的，过程中自己在 Github 上建了一个模拟的 <a href="https://github.com/JonyFang/GitTestDemo">Demo</a> 用来熟悉 git flow。其实从理解到动手完成还是有点距离的，笨人有笨法嘛。如有不准确的地方欢迎指正。: )</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#git-" id="markdown-toc-git-">Git 常用命令</a>    <ul>
      <li><a href="#section" id="markdown-toc-section">1. 新开分支</a></li>
      <li><a href="#section-1" id="markdown-toc-section-1">2. 切换到另一个分支</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">3. 新开分支并切换到新分支</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">4. 查看分支列表</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">5. 查看远程分支列表</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">6. 向远程仓库提交本地新开的分支</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">7. 删除远程分支</a></li>
      <li><a href="#section-7" id="markdown-toc-section-7">8. 删除本地分支</a></li>
      <li><a href="#section-8" id="markdown-toc-section-8">9. 更新分支列表信息</a></li>
    </ul>
  </li>
  <li><a href="#git-flow-" id="markdown-toc-git-flow-">Git Flow 梳理</a>    <ul>
      <li><a href="#section-9" id="markdown-toc-section-9">1.主要分支</a></li>
      <li><a href="#section-10" id="markdown-toc-section-10">2.辅助分支</a>        <ul>
          <li><a href="#feature-branches" id="markdown-toc-feature-branches">2.1.Feature branches（功能分支）</a></li>
          <li><a href="#release-branches" id="markdown-toc-release-branches">2.2.Release branches（预发布分支）</a></li>
          <li><a href="#hotfix-branches" id="markdown-toc-hotfix-branches">2.3.Hotfix branches（热修复分支）</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-11" id="markdown-toc-section-11">总结</a></li>
</ul>

<h1 id="git-">Git 常用命令</h1>

<p>这里列出了一些比较常用的 git 命令，每个命令介绍后面都带一个简单例子～</p>

<h3 id="section">1. 新开分支</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">branch</span> <span class="err">新分支名</span>
</span><span class="line">	
</span><span class="line"> <span class="c1">#新建分支 develop</span>
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">branch</span> <span class="n">develop</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-1">2. 切换到另一个分支</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="err">分支名</span>
</span><span class="line">
</span><span class="line"> <span class="c1">#切换到 develop 分支</span>
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="n">develop</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-2">3. 新开分支并切换到新分支</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="err">新分支名</span>
</span><span class="line">
</span><span class="line"> <span class="c1">#新开 develop 分支，并切换到此分支</span>
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="n">develop</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-3">4. 查看分支列表</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">branch</span> <span class="o">-</span><span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>头部带 remotes/origin 的，表示远程分支</p>

<h3 id="section-4">5. 查看远程分支列表</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">branch</span> <span class="o">-</span><span class="n">r</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-5">6. 向远程仓库提交本地新开的分支</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="err">新开分支名</span>
</span><span class="line">
</span><span class="line"> <span class="c1">#提交新建的 develop 分支</span>
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">develop</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-6">7. 删除远程分支</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="o">--</span><span class="n">delete</span> <span class="err">远程分支名</span>
</span><span class="line">
</span><span class="line"> <span class="c1">#删除远程仓库中的 develop 分支</span>
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="o">--</span><span class="n">delete</span> <span class="n">develop</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-7">8. 删除本地分支</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">branch</span> <span class="o">-</span><span class="n">d</span> <span class="err">分支名</span>
</span><span class="line">
</span><span class="line"> <span class="c1">#删除本地的 develop 分支</span>
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">branch</span> <span class="o">-</span><span class="n">d</span> <span class="n">develop</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-8">9. 更新分支列表信息</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">fetch</span> <span class="o">-</span><span class="nb">p</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>用于协作时，项目队友添加或删除了远程分支的分支，可以通过这种方式来刷新分支列表信息</p>

<hr />

<h1 id="git-flow-">Git Flow 梳理</h1>

<p><span class="caption-wrapper"><img class="caption" src="http://7xob7d.com1.z0.glb.clouddn.com/git_flow.png" width="575" height="" title="git flow 图示" /><span class="caption-text">git flow 完整图示</span></span></p>

<p>Git 开发模式本质上是一套流程，团队每个成员遵守这套流程以确保完成可控的软件开发过程。<a href="http://nvie.com/posts/a-successful-git-branching-model/">原文参考</a></p>

<h2 id="section-9">1.主要分支</h2>

<p>在远程仓库中有两个主要分支的生命期可以无限长，分别是：</p>

<p><strong><code>Master</code></strong></p>

<p><strong><code>Develop</code></strong></p>

<p><span class="caption-wrapper"><img class="caption" src="http://jonyfang.github.io/images/git_flow/develop_branch.png" width="267" height="" title="develop 和 master 关系图" /><span class="caption-text">develop 和 master 关系图</span></span></p>

<p><strong>master 分支（origin/master）</strong></p>

<p>代码仓库中有且仅有的一条主分支，默认为 master ，在创建版本库时会自动创建。所有提供给用户使用的正式版本的源码，都会在这个分支上发布。也就是说主分支 master 用来发布重大版本。</p>

<p><strong>develop 分支（origin/develop）</strong></p>

<p>日常开发工作都会在 develop 分支上面完成。develop 分支可以用来生成代码的最新隔夜版本（nightly builds）。</p>

<p><strong>创建 <code>develop</code> 分支</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="n">develop</span> <span class="n">master</span>
</span><span class="line">
</span><span class="line"> <span class="c1">#push develop 到远程仓库</span>
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">develop</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当我们在<code>develop</code>上完成了新版本的功能，最终会把所有的修改 <code>merge</code> 到 <strong><code>master</code></strong> 分支。针对每次 <strong><code>master</code></strong> 的修改都会打一个 Tag 作为可发布产品的版本号。</p>

<h2 id="section-10">2.辅助分支</h2>

<p>开发过程中不可能项目人所有都在一个 <code>develop</code> 分支中开发，版本管理会很混乱。所以除了主要分支外，我们还需要一些辅助分支来协助团队成员间的并行开发。</p>

<p><strong>所用到的辅助分支大体分三类：</strong></p>

<ul>
  <li><strong>Feature branches（功能分支）</strong></li>
  <li><strong>Release branches（预发布分支）</strong></li>
  <li><strong>Hotfix branches（热修复分支）</strong></li>
</ul>

<p>通过分支名我们能知道各类型分支都有特定作用，对于他们各自的起始分支和最终的合并分支也都有严格规定。呼，虽然可能会麻烦点，但让人一目了然的效果还是很诱人的。</p>

<p>下面逐一介绍下各类型分支的创建使用和移除方法，过程中我在 <code>Github</code> 中创建一个虚拟的项目用来熟悉整个流程，或许你也可以像我一样做一遍。哈，动手总会有意外收获嘛。废话少说，继续正题～</p>

<h3 id="feature-branches">2.1.Feature branches（功能分支）</h3>

<p><span class="caption-wrapper"><img class="caption" src="http://7xob7d.com1.z0.glb.clouddn.com/feature_branches.png" width="133" height="" title="feature_branches" /><span class="caption-text">feature_branches</span></span></p>

<p><strong>应用场景：</strong></p>

<p>当要开始一个新功能的开发时，我门可以创建一个 <code>Feature branche</code> 。等待这个新功能开发完成并确定应用到新版本中就合并回 <code>develop</code>，那么如果不是就会被很遗憾的丢弃。。。</p>

<p><strong>应用规则：</strong></p>

<ol>
  <li>
    <p>从 <code>develop</code> 分支创建，最终合并回 <code>develop</code> 分支;</p>
  </li>
  <li>
    <p>分支名：feature／＊;</p>
  </li>
</ol>

<p>Tips：这里很多地方说用 <strong>feature-＊</strong> 的方式命名，因为公司项目中用的 <strong>feature／＊</strong>方式，也就习惯了，其实意思是一样的。</p>

<h4 id="creat-a-feature-branch">(1).Creat a feature branch</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="n">feature</span><span class="o">/</span><span class="nb">test</span> <span class="n">develop</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>do something in <code>feature/test</code> branch</p>

<p>push 本地 <code>feature/test</code> 到远处代码库；</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">feature</span><span class="o">/</span><span class="nb">test</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="develop--featuretest">(2).切换到 <strong>develop</strong> 合并 <strong>feature/test</strong></h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="n">develop</span>
</span><span class="line">
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">merge</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">ff</span> <span class="n">feature</span><span class="o">/</span><span class="nb">test</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>”- -no-ff” 的作用是创建一个新的 “commit” 对象用于当前合并操作。这样既可以避免丢失该功能分支的历史存在信息，又可以集中该功能分支所有历史提交。并且如果想回退版本也会比较方便。</p>

<p><span class="caption-wrapper"><img class="caption" src="http://7xob7d.com1.z0.glb.clouddn.com/git_merge_noff.png" width="478" height="" title="git merge --no-ff 图示" /><span class="caption-text">git merge - -no-ff 图示</span></span></p>

<h4 id="featuretest-">(3).移除本地和远程仓库的 <strong>feature/test</strong> 分支</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">branch</span> <span class="o">-</span><span class="n">d</span> <span class="n">feature</span><span class="o">/</span><span class="nb">test</span>
</span><span class="line">
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="o">--</span><span class="n">delete</span> <span class="n">feature</span><span class="o">/</span><span class="nb">test</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="release-branches">2.2.Release branches（预发布分支）</h3>

<p><strong>应用场景：</strong></p>

<p>“Release branches” 用来做新版本发布前的准备工作，在上面可以做一些小的 bug 修复、准备发布版本号等等和发布有关的小改动，其实已经是一个比较成熟的版本了。另外这样我们既可以在预发布分支上做一些发布前准备，也不会影响 “develop” 分支上下一版本的新功能开发。</p>

<p><strong>应用规则：</strong></p>

<ol>
  <li>
    <p>从 <code>develop</code> 分支创建，最终合并回 <code>develop</code> 和 <code>master</code>;</p>
  </li>
  <li>
    <p>分支名：release-＊;</p>
  </li>
</ol>

<h4 id="creat-a-release-branch">(1).Creat a release branch</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="n">release</span><span class="o">-</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span> <span class="n">develop</span>
</span><span class="line">
</span><span class="line"> <span class="c1">#push 到远程仓库（可选）</span>
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">release</span><span class="o">-</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>do something in <code>release-1.1</code> branch</p>

<h4 id="master--release-11">(2).切换到 <strong>master</strong> 合并 <strong>release-1.1</strong></h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="n">master</span>
</span><span class="line">
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">merge</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">ff</span> <span class="n">release</span><span class="o">-</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span>
</span><span class="line">
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">tag</span> <span class="o">-</span><span class="n">a</span> <span class="mi">1</span><span class="o">.</span><span class="mi">1</span>
</span><span class="line">
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="mi">1</span><span class="o">.</span><span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当我们的 <code>release-1.1</code> 的 Review 完成，也就预示着我们可以发布了。打上相应的版本号，再 <strong>push</strong> 到远程仓库。</p>

<h4 id="develop--release-11">(3).切换到 <strong>develop</strong> 合并 <strong>release-1.1</strong></h4>

<p>预发布分支所做的修改同时也要合并回 <strong>develop</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="n">develop</span>
</span><span class="line">
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">merge</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">ff</span> <span class="n">release</span><span class="o">-</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="release-11">(4).移除本地和远程仓库的 <strong>release-1.1</strong></h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">branch</span> <span class="o">-</span><span class="n">d</span> <span class="n">release</span><span class="o">-</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span>
</span><span class="line">
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="o">--</span><span class="n">delete</span> <span class="n">release</span><span class="o">-</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="hotfix-branches">2.3.Hotfix branches（热修复分支）</h3>

<p><span class="caption-wrapper"><img class="caption" src="http://7xob7d.com1.z0.glb.clouddn.com/hotfixes.png" width="316" height="" title="Hotfix branches 图示" /><span class="caption-text">Hotfix branches 图示</span></span></p>

<p><strong>应用场景：</strong></p>

<p>“Hotfix branches” 主要用于处理线上版本出现的一些需要立刻修复的 bug 情况.</p>

<p><strong>应用规则：</strong></p>

<ol>
  <li>
    <p>从 <code>master</code> 分支上当前版本号的 <code>tag</code> 处切出，也就是从最新的 <code>master</code> 上创建，最终合并回 <code>develop</code> 和 <code>master</code>;</p>
  </li>
  <li>
    <p>分支名：hotfix-＊;</p>
  </li>
</ol>

<h4 id="creat-a-fixbug-branch">(1).Creat a fixbug branch</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="n">fixbug</span><span class="o">-</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span> <span class="n">master</span>
</span><span class="line">
</span><span class="line"> <span class="c1">#push 到远程仓库（可选）</span>
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">fixbug</span><span class="o">-</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>do something in <code>fixbug-1.1.1</code> branch</p>

<h4 id="master--fixbug-111">(2).切换到 <strong>master</strong> 合并 <strong>fixbug-1.1.1</strong></h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="n">master</span>
</span><span class="line">
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">merge</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">ff</span> <span class="n">fixbug</span><span class="o">-</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span>
</span><span class="line">
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">tag</span> <span class="o">-</span><span class="n">a</span> <span class="mi">1</span><span class="o">.</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span>
</span><span class="line">
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="mi">1</span><span class="o">.</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span><span class="sb">`</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>bug 修复完成，合并回 <code>master</code> 并打上版本号；</p>

<h4 id="develop--fixbug111">(3).切换到 <strong>develop</strong> 合并 <strong>fixbug－1.1.1</strong></h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="n">develop</span>
</span><span class="line">
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">merge</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">ff</span> <span class="n">fixbug</span><span class="o">-</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="fixbug-111">(4).移除本地和远程仓库的 <strong>fixbug-1.1.1</strong></h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">branch</span> <span class="o">-</span><span class="n">d</span> <span class="n">fixbug</span><span class="o">-</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span>
</span><span class="line">
</span><span class="line"> <span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="o">--</span><span class="n">delete</span> <span class="n">fixbug</span><span class="o">-</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span><span class="o">.</span><span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h1 id="section-11">总结</h1>

<p>啊哈，又到尾声了。上面的 <code>Git 常用命令</code>和 <code>Git Flow</code> 只是一些基本常识，并没有什么新的东西加入。在平时的团队协作中有些对于我自身而言还是比较新鲜的，比如 tag ，这些一般都交给老大来弄（因为他要 review）：D 。好像跑偏了。。。对自己而言，理一遍后的收获还是不小的，对 Git Flow 的整个流程有了大概的了解，但具体每个 git 命令内部是怎么处理的呢，这个留到后面再梳理一下～</p>

<blockquote>
  <p>参考内容：
<br /><br />
<a href="http://www.ruanyifeng.com/blog/2012/07/git.html">Git分支管理策略</a>
<br />
<a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocoapods 版本升级]]></title>
    <link href="http://jonyfang.com/blog/2015/11/09/update_cocoapods/"/>
    <updated>2015-11-09T06:40:00+08:00</updated>
    <id>http://jonyfang.com/blog/2015/11/09/update_cocoapods</id>
    <content type="html"><![CDATA[<p class="info">升级 OS X El Capitan 后，Time Machine 恢复下，随后因为遇到 octopress 无法更新博客问题，一番折腾 <a href="http://www.jianshu.com/p/ce5eff554279">octopress 适配了 OS X El Capitan</a>，然而事情总没有那么简单，又丢过来一个问题。</p>

<!-- more -->


<p>和往常一样使用 Cocoapods ，执行命令：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">pod</span> <span class="n">install</span>
</span><span class="line"> <span class="c1">#输出信息</span>
</span><span class="line"><span class="sr">/System/</span><span class="no">Library</span><span class="o">/</span><span class="no">Frameworks</span><span class="o">/</span><span class="no">Ruby</span><span class="o">.</span><span class="n">framework</span><span class="o">/</span><span class="no">Versions</span><span class="o">/</span><span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">ruby</span><span class="o">/</span><span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">/</span><span class="n">rubygems</span><span class="o">/</span><span class="n">dependency</span><span class="o">.</span><span class="n">rb</span><span class="p">:</span><span class="mi">296</span><span class="ss">:in</span> <span class="sb">`to_specs&#39;: Could not find &#39;cocoapods&#39; (&gt;= 0) among 59 total gem(s) (Gem::LoadError)</span>
</span><span class="line"><span class="sb">	from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/rubygems/dependency.rb:307:in `</span><span class="n">to_spec</span><span class="s1">&#39;</span>
</span><span class="line"><span class="s1">	from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/rubygems/core_ext/kernel_gem.rb:47:in `gem&#39;</span>
</span><span class="line">	<span class="n">from</span> <span class="sr">/usr/</span><span class="n">local</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="ss">pod</span><span class="p">:</span><span class="mi">22</span><span class="ss">:in</span> <span class="sb">`&lt;main&gt;&#39;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>查看 <code>Ruby</code> 版本：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">ruby</span> <span class="o">-</span><span class="n">v</span>
</span><span class="line"> <span class="n">ruby</span> <span class="mi">2</span><span class="o">.</span><span class="mi">2</span><span class="o">.</span><span class="mi">3</span><span class="n">p173</span> <span class="p">(</span><span class="mi">2015</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">18</span> <span class="n">revision</span> <span class="mi">51636</span><span class="p">)</span> <span class="o">[</span><span class="n">x86_64</span><span class="o">-</span><span class="n">darwin14</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>看来是升级 <code>Ruby 2.2.3</code> 导致的问题，更新下 Cocoapods 即可，更新步骤：</p>

<p>1、 更新 gem ，国内需切换 <code>gem source</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">sudo</span> <span class="n">gem</span> <span class="n">update</span> <span class="o">--</span><span class="nb">system</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>切换 <code>gem source</code></li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"><span class="err">$</span> <span class="n">gem</span> <span class="n">sources</span> <span class="o">--</span><span class="n">add</span> <span class="ss">https</span><span class="p">:</span><span class="sr">//</span><span class="n">ruby</span><span class="o">.</span><span class="n">taobao</span><span class="o">.</span><span class="n">org</span><span class="o">/</span> <span class="o">--</span><span class="n">remove</span> <span class="ss">https</span><span class="p">:</span><span class="sr">//</span><span class="n">rubygems</span><span class="o">.</span><span class="n">org</span><span class="o">/</span>
</span><span class="line">
</span><span class="line"><span class="err">$</span> <span class="n">gem</span> <span class="n">sources</span> <span class="o">-</span><span class="n">l</span>
</span><span class="line"><span class="o">***</span> <span class="no">CURRENT</span> <span class="no">SOURCES</span><span class="o">***</span>
</span><span class="line">
</span><span class="line"><span class="ss">https</span><span class="p">:</span><span class="sr">//</span><span class="n">ruby</span><span class="o">.</span><span class="n">taobao</span><span class="o">.</span><span class="n">org</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>2、 安装 <code>cocoapods</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">sudo</span> <span class="n">gem</span> <span class="n">install</span> <span class="n">cocoapods</span>
</span><span class="line"> <span class="err">$</span> <span class="n">pod</span> <span class="n">setup</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>和安装过程是一样的，再次查看 <code>pod</code> 版本：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">pod</span> <span class="o">--</span><span class="n">version</span>
</span><span class="line">
</span><span class="line"> <span class="mi">0</span><span class="o">.</span><span class="mi">39</span><span class="o">.</span><span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>搞定～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress 适配 OS X El Capitan]]></title>
    <link href="http://jonyfang.com/blog/2015/11/08/octopress_adapt_to_elcapitan/"/>
    <updated>2015-11-08T16:30:00+08:00</updated>
    <id>http://jonyfang.com/blog/2015/11/08/octopress_adapt_to_elcapitan</id>
    <content type="html"><![CDATA[<p class="info">这几天装上 OS X El Capitan ，Time Machine 恢复后测试 Octopress 遇到无法使用问题，这里总结下问题的解决过程。</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">一.解决办法</a>    <ul>
      <li><a href="#rvm" id="markdown-toc-rvm">1.1. 安装 RVM</a></li>
      <li><a href="#ruby-223" id="markdown-toc-ruby-223">1.2. 安装 Ruby 2.2.3</a></li>
      <li><a href="#octopress-" id="markdown-toc-octopress-">1.3. 安装 Octopress 依赖库</a></li>
    </ul>
  </li>
</ul>

<!-- more -->

<p>首先打开终端，运行：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">rake</span> <span class="n">preview</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>报错如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"><span class="err">$</span> <span class="n">rakepreviewStarting</span> <span class="n">to</span> <span class="n">watchsourcewith</span> <span class="no">Jekyll</span> <span class="ow">and</span> <span class="no">Compass</span><span class="o">.</span> <span class="no">Starting</span> <span class="no">Rack</span> <span class="n">on</span> <span class="n">port</span>
</span><span class="line">
</span><span class="line"><span class="mi">4000</span><span class="n">rake</span> <span class="n">aborted!</span><span class="no">Errno</span><span class="o">::</span><span class="ss">ENOENT</span><span class="p">:</span> <span class="no">No</span> <span class="n">such</span> <span class="n">file</span> <span class="ow">or</span> <span class="n">directory</span> <span class="o">-</span>
</span><span class="line">
</span><span class="line"><span class="n">compass</span><span class="o">/</span><span class="no">Users</span><span class="o">/</span><span class="n">user</span><span class="o">/</span><span class="n">git</span><span class="o">/</span><span class="n">octopress</span><span class="o">/</span><span class="ss">Rakefile</span><span class="p">:</span><span class="mi">85</span><span class="ss">:in</span>
</span><span class="line">
</span><span class="line"><span class="n">spawn</span><span class="o">/</span><span class="no">Users</span><span class="o">/</span><span class="n">user</span><span class="o">/</span><span class="n">git</span><span class="o">/</span><span class="n">octopress</span><span class="o">/</span><span class="ss">Rakefile</span><span class="p">:</span><span class="mi">85</span><span class="ss">:in</span> <span class="n">block</span> <span class="ss">inTasks</span><span class="p">:</span><span class="no">TOP</span><span class="o">=&gt;</span> <span class="n">preview</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在没有升级 OS X EI Capitan 之前一切如常，首先想到是不是 Ruby 的问题</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">ruby</span> <span class="o">-</span><span class="n">v</span>
</span><span class="line">
</span><span class="line"> <span class="c1">#输出</span>
</span><span class="line"> <span class="n">ruby</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="n">p645</span> <span class="p">(</span><span class="mi">2015</span><span class="o">-</span><span class="mo">04</span><span class="o">-</span><span class="mi">13</span> <span class="n">revision</span> <span class="mi">50299</span><span class="p">)</span> <span class="o">[</span><span class="n">universal</span><span class="o">.</span><span class="n">x86_64</span><span class="o">-</span><span class="n">darwin15</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>和以前一样还是 2.0.0 版本，到官网查看最新版本是 2.2.3，多次尝试更新 <code>ruby</code> 失败。</p>

<h2 id="section">一.解决办法</h2>
<p>更新 Ruby 可以通过 <code>rbenv</code> 或 <code>RVM</code>，因为我之前安装是通过 <code>RVM</code> 的方式，这里自己也是通过 <code>RVM</code> 的方式解决的。（附 Google 看到的：<a href="https://gorails.com/setup/osx/10.11-el-capitan">rbenv 更新 Ruby 方法</a>）</p>

<h3 id="rvm">1.1. 安装 RVM</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">curl</span> <span class="o">-</span><span class="n">L</span> <span class="ss">https</span><span class="p">:</span><span class="sr">//</span><span class="n">get</span><span class="o">.</span><span class="n">rvm</span><span class="o">.</span><span class="n">io</span> <span class="o">|</span> <span class="n">bash</span> <span class="o">-</span><span class="n">s</span> <span class="n">stable</span> <span class="o">--</span><span class="n">ruby</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p class="addition">这里自己安装 <strong>RVM</strong> 过程中遇到安装冲突的情况，通过下面的命令清理缓存后恢复了。<code>$ rm -rf /usr/local/.git</code></p>

<h3 id="ruby-223">1.2. 安装 Ruby 2.2.3</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">rvm</span> <span class="n">install</span> <span class="mi">2</span><span class="o">.</span><span class="mi">2</span><span class="o">.</span><span class="mi">3</span>
</span><span class="line"> <span class="err">$</span> <span class="n">rvm</span> <span class="n">use</span> <span class="mi">2</span><span class="o">.</span><span class="mi">2</span><span class="o">.</span><span class="mi">3</span>
</span><span class="line"> <span class="err">$</span> <span class="n">rvm</span> <span class="n">rubygems</span> <span class="n">latest</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>查看下 Ruby 版本:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">ruby</span> <span class="o">-</span><span class="n">v</span>
</span><span class="line"> <span class="err">$</span> <span class="n">ruby</span> <span class="mi">2</span><span class="o">.</span><span class="mi">2</span><span class="o">.</span><span class="mi">3</span><span class="n">p173</span> <span class="p">(</span><span class="mi">2015</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">18</span> <span class="n">revision</span> <span class="mi">51636</span><span class="p">)</span> <span class="o">[</span><span class="n">x86_64</span><span class="o">-</span><span class="n">darwin14</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>啊哈，切换过来了，其实也很简单，到这里就修复了吗？其实还没有，如你所见还有第4步。</p>

<h3 id="octopress-">1.3. 安装 Octopress 依赖库</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">cd</span> <span class="n">octopress</span>
</span><span class="line"> <span class="err">$</span> <span class="n">sudo</span> <span class="n">gem</span> <span class="n">install</span> <span class="n">bundler</span>
</span><span class="line"> <span class="err">$</span> <span class="n">bundle</span> <span class="n">install</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当 bundler 安装完毕之后，来测试下 <code>rake</code> 命令是否修复了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"> <span class="err">$</span> <span class="n">rake</span> <span class="n">generate</span>
</span><span class="line"> <span class="c1">## Generating Site with Jekyll</span>
</span><span class="line">    <span class="n">write</span> <span class="n">source</span><span class="o">/</span><span class="n">stylesheets</span><span class="o">/</span><span class="n">screen</span><span class="o">.</span><span class="n">css</span>
</span><span class="line"><span class="no">Configuration</span> <span class="ss">file</span><span class="p">:</span> <span class="sr">/Users/</span><span class="no">JonyFang</span><span class="o">/</span><span class="no">Desktop</span><span class="o">/</span><span class="n">octopress</span><span class="o">/</span><span class="n">_config</span><span class="o">.</span><span class="n">yml</span>
</span><span class="line">            <span class="ss">Source</span><span class="p">:</span> <span class="n">source</span>
</span><span class="line">       <span class="ss">Destination</span><span class="p">:</span> <span class="kp">public</span>
</span><span class="line">      <span class="no">Generating</span><span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class="line">                    <span class="n">done</span><span class="o">.</span>
</span><span class="line"> <span class="no">Auto</span><span class="o">-</span><span class="ss">regeneration</span><span class="p">:</span> <span class="n">disabled</span><span class="o">.</span> <span class="no">Use</span> <span class="o">--</span><span class="n">watch</span> <span class="n">to</span> <span class="n">enable</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>可以了～</p>

<p>如果你也同样遇到升级 OS X EI Capitan 后 Octopress 无法使用的情况，希望能对你有所帮助。</p>

<blockquote>
  <p>本文参考：
<br /><br />
<a href="https://github.com/imathis/octopress/issues/1749">When I upgraded the Mac system, I can’t Preview</a>
<br /><br />
<a href="https://gorails.com/setup/osx/10.11-el-capitan">Setup Ruby On Rails on Mac OS X 10.11 El Capitan</a></p>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于 Octopress &amp; Github Pages 搭建博客（二）]]></title>
    <link href="http://jonyfang.com/blog/2015/10/16/starting_blog_with_octopress_2/"/>
    <updated>2015-10-16T02:37:44+08:00</updated>
    <id>http://jonyfang.com/blog/2015/10/16/starting_blog_with_octopress_2</id>
    <content type="html"><![CDATA[<p class="info">经过<a href="http://jonyfang.github.io/blog/2015/10/13/ji-yu-octopress-he-github-da-jian-bo-ke/">上一篇</a>，我们在本地搭出了 Octopress 雏形，这一篇首先我们要将本地的 Octopress 博客部署到 Github Pages ，然后发布一篇博文。部署过程中分析了原理，可能会比较枯燥，但是能让我们更了解 Octopress，所以我依旧坚持写下来了。
<br /><br />
废话少说，开工～</p>
<!-- more -->

<ul id="markdown-toc">
  <li><a href="#octopress--github-pages" id="markdown-toc-octopress--github-pages">一. 将 Octopress 部署到 Github Pages</a>    <ul>
      <li><a href="#github-repository" id="markdown-toc-github-repository">1.1. 新建 Github repository</a></li>
      <li><a href="#github-pages" id="markdown-toc-github-pages">1.2. 配置 Github Pages</a></li>
      <li><a href="#section" id="markdown-toc-section">1.3. 生成并部署站点</a></li>
    </ul>
  </li>
  <li><a href="#section-1" id="markdown-toc-section-1">二. 发布博文过程</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">2.1. 新建一篇博文</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">2.2. 预览新建的博文</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">2.3. 发布新建的博文</a></li>
    </ul>
  </li>
</ul>

<h2 id="octopress--github-pages">一. 将 Octopress 部署到 Github Pages</h2>

<p>Github 大家应该都有了解过，也是我很喜欢的平台之一，功能真心强大并且可免费使用，这里我们拿来托管我们的博客。</p>

<h3 id="github-repository">1.1. 新建 Github repository</h3>

<p>注册 Github 账号，新建 <a href="https://github.com/new">Github repository</a>。<code>项目名称</code>（Repository name）命名格式为 <code>username.github.io</code> ，<code>username</code> 是你的 <code>Github 用户名</code>（或 organization name，这里和后面我们先不讨论 origanization）。例如我的用户名是 JonyFang，所以输入 JonyFang.github.io 即可。点击 <code>Create repository</code> 创建。</p>

<p class="info">创建完后不要添加任何内容，另外自己过程中产生了两个疑问
<br />
1.为什么用 github.io 而不是 github.com？
<br />
2.为什么是 Repository name 一定要按照 username.github.io 填写？</p>

<p>第一个问题，<a href="https://github.com/blog/1452-new-github-pages-domain-github-io#security-vulnerability">这里</a>解释了为什么把 <code>github.com</code> 改为了 <code>github.io</code>，简而言之是为了安全。</p>

<p>第二个问题，和 Github 内部的结构有关，其次后面会通过 URL 截取填写的 <code>username.github.io</code> 作为博客域名。这样填写格式与 Github 内部结构的具体联系还需要再研究下。若有大神围观，望指教下：）</p>

<h3 id="github-pages">1.2. 配置 Github Pages</h3>

<p>终端执行如下命令：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">cd</span> <span class="n">octopress</span>
</span><span class="line">  <span class="err">$</span> <span class="n">rake</span> <span class="n">setup_github_pages</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>该命令会要求我们输入 Github 仓库的 URL 。复制粘贴下我们新建仓库的 <code>SSH</code> 或 <code>HTTPS</code> URL 即可。
（例如：git@github.com:username/username.github.io.git）</p>

<p>那么这里 rake setup_github_pages 做了什么呢？</p>

<p>用户（users）的 Github Pages 使用 <code>master</code> 分支作为 <code>Web 服务</code>（web server）的公开目录，为我们的 <code>Pages url</code> （http://username.github.io）提供内容文件。因此，我们会有这样的需求，<code>source</code> 分支用来做与<code>博客源码</code>相关的事（存放全部博客源码），<code>master</code> 分支上 commit 生成的博客内容<code>供 Web 访问</code>。而 Octopress 帮我们把这件事给搞定了，通过这行 code（好 NB～）。</p>

<p class="info">下面具体分析下 Octopress 是怎么做的（可通过查看 Rakefile 得知）：</p>

<p>(1). 命令要求我们输入 Github Pages 仓库的 URL，也就是我们新建的名为 username.github.io 仓库的 URL。这样命名是为了通过字符串截取 URL 拿到子串（http://username.github.io）作为我们博客的域名；</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="c1"># Rakefile 中可查看 URL 截取方式：</span>
</span><span class="line">  <span class="n">repo_url</span> <span class="o">=</span> <span class="n">get_stdin</span><span class="p">(</span><span class="s2">&quot;Repository url: &quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(2). 将指向（pointing to）imathis/octopress 远程库的名字 <code>‘origin’</code> 改为 <code>‘octopress’</code>；</p>

<p>Git clone 一个仓库时，会将 clone 下来的仓库命名为 origin，没有限定 clone 条件的情况下，会下载仓库中所有数据，并建立一个指向该仓库 master 分支的指针，本地命名为 <code>origin/master</code>。</p>

<p>当我们 clone 了 octopress 仓库，执行如下命令可看到远程仓库信息：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">cd</span> <span class="n">octopress</span>
</span><span class="line">  <span class="err">$</span> <span class="n">git</span> <span class="n">remote</span> <span class="o">-</span><span class="n">v</span>
</span><span class="line">
</span><span class="line">  <span class="c1"># 输出如下，可看到远程仓库名为 origin</span>
</span><span class="line">  <span class="n">origin</span>	<span class="ss">git</span><span class="p">:</span><span class="sr">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">imathis</span><span class="o">/</span><span class="n">octopress</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">fetch</span><span class="p">)</span>
</span><span class="line">  <span class="n">origin</span>	<span class="ss">git</span><span class="p">:</span><span class="sr">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">imathis</span><span class="o">/</span><span class="n">octopress</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">push</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>Rakefile</code> 中可看出是通过如下的方式，将 origin 改为 octopress:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="c1"># 查看 Rakefile</span>
</span><span class="line">  <span class="nb">system</span> <span class="s2">&quot;git remote rename origin octopress&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里内部执行了命令 <code>git remote rename origin octopress</code>，当 <code>rake setup_github_pages</code> 执行完毕，再 <code>git remote -v</code> 发现远程库名改为了 octopress。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">git</span> <span class="n">remote</span> <span class="o">-</span><span class="n">v</span>
</span><span class="line">  <span class="c1"># 输出如下</span>
</span><span class="line">  <span class="n">octopress</span>	  <span class="ss">git</span><span class="p">:</span><span class="sr">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">imathis</span><span class="o">/</span><span class="n">octopress</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">fetch</span><span class="p">)</span>
</span><span class="line">  <span class="n">octopress</span>	  <span class="ss">git</span><span class="p">:</span><span class="sr">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">imathis</span><span class="o">/</span><span class="n">octopress</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">push</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(3). 添加你的 Github Pages 仓库作为默认的 origin remote，并将远程库中指向 imathis/octopress 中 master 分支的指针指向现在的 origin（即 username/username.github.io）的 master 分支，</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="c1"># 查看 Rakefile</span>
</span><span class="line">  <span class="nb">system</span> <span class="s2">&quot;git remote add origin </span><span class="si">#{</span><span class="n">repo_url</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class="line">  <span class="nb">system</span> <span class="s2">&quot;git config branch.master.remote origin&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当 <code>rake setup_github_pages</code> 执行完毕查看远程库，可以看到远程库 origin 指向了 Github Pages。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">cd</span> <span class="n">octopress</span>
</span><span class="line">  <span class="err">$</span> <span class="n">git</span> <span class="n">remote</span> <span class="o">-</span><span class="n">v</span>
</span><span class="line">
</span><span class="line">  <span class="c1"># 输出信息如下</span>
</span><span class="line">  <span class="n">octopress</span>	<span class="ss">git</span><span class="p">:</span><span class="sr">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">imathis</span><span class="o">/</span><span class="n">octopress</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">fetch</span><span class="p">)</span>
</span><span class="line">  <span class="n">octopress</span>	<span class="ss">git</span><span class="p">:</span><span class="sr">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">imathis</span><span class="o">/</span><span class="n">octopress</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">push</span><span class="p">)</span>
</span><span class="line">  <span class="n">origin</span>	<span class="n">git</span><span class="vi">@github</span><span class="o">.</span><span class="n">com</span><span class="ss">:JonyFang</span><span class="o">/</span><span class="no">JonyFang</span><span class="o">.</span><span class="n">github</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">fetch</span><span class="p">)</span>
</span><span class="line">  <span class="n">origin</span>	<span class="n">git</span><span class="vi">@github</span><span class="o">.</span><span class="n">com</span><span class="ss">:JonyFang</span><span class="o">/</span><span class="no">JonyFang</span><span class="o">.</span><span class="n">github</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">git</span> <span class="p">(</span><span class="n">push</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>到这里，应该能猜到上一步将指向 <code>imathis/octopress</code> 远程库的名字 <code>origin</code> 改为 <code>octopress</code> 的原因了。</p>

<p>(4). 将本地 master 分支名字从 <code>master</code> 改为 <code>source</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="c1"># 查看 Rakefile</span>
</span><span class="line">  <span class="nb">system</span> <span class="s2">&quot;git branch -m master source&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>执行如下命令查看本地分支（拿到第6条解释为什么要改名为 source）：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">git</span> <span class="n">branch</span>
</span><span class="line">
</span><span class="line">  <span class="c1"># 输出如下</span>
</span><span class="line">  <span class="o">*</span> <span class="n">source</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(5). 根据提供的 Github Pages 仓库的 <code>SSH</code> 或 <code>HTTPS</code> 的 URL，截取仓库名 <code>username.github.io</code> 作为博客的 URL（上面 1 有提到）。然后将 octopress 目录下 <code>_config.yml</code> 文件中 url 参数值改为 <code>http：//username.github.io</code>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="c1"># octopress 下 Rakefile 查看</span>
</span><span class="line">
</span><span class="line">  <span class="n">url</span> <span class="o">=</span> <span class="n">blog_url</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">project</span><span class="p">,</span> <span class="n">source_dir</span><span class="p">)</span>
</span><span class="line">  <span class="n">jekyll_config</span> <span class="o">=</span> <span class="no">IO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;_config.yml&#39;</span><span class="p">)</span>
</span><span class="line">  <span class="n">jekyll_config</span><span class="o">.</span><span class="n">sub!</span><span class="p">(</span><span class="sr">/^url:.*$/</span><span class="p">,</span> <span class="s2">&quot;url: </span><span class="si">#{</span><span class="n">url</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span class="line">  <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;_config.yml&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span>
</span><span class="line">  <span class="n">f</span><span class="o">.</span><span class="n">write</span> <span class="n">jekyll_config</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(6). 在 octopress 目录下新建 <code>_deploy</code> 目录，并在 _deploy目录下新建 <code>master</code> 分支；</p>

<p>前面4 ，我们将本地 master 分支名字从 <code>master</code> 改为 <code>source</code>，这里一起分析下原因。4和6放在一起容易理解点。</p>

<p>其实本地 octopress 博客部署到 Github Pages 之后，远程 Github 下会有两个分支， <code>master</code> 和 <code>source</code>。远程 <code>master</code> 分支作为 <code>Web 服务</code>公开目录，当你访问 <code>http://username.github.io</code> 时，提供网站内容；远程 <code>source</code> 分支存放的是整个 <code>octopress 框架</code>的源码。</p>

<p>之所以第4步将本地 <code>master</code> 改为 <code>source</code>，是为了把 <code>master 指针</code>让出来，让它指向这一步（6）新建的 <code>_deploy</code> 目录下的 master 分支。这样，<code>octopress/_deploy</code> 目录下的本地 master 分支 就对应了 Github Pages 远程库中的 master 分支，本地 source 分支同理。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="c1"># 查看 Rakefile </span>
</span><span class="line">  <span class="n">cd</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">deploy_dir</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">do</span>
</span><span class="line">  <span class="nb">system</span> <span class="s2">&quot;git init&quot;</span>
</span><span class="line">  <span class="nb">system</span> <span class="s1">&#39;echo &quot;My Octopress Page is coming soon …&quot; &gt; index.html&#39;</span>
</span><span class="line">  <span class="nb">system</span> <span class="s2">&quot;git add .&quot;</span>
</span><span class="line">  <span class="nb">system</span> <span class="s2">&quot;git commit -m </span><span class="se">\&quot;</span><span class="s2">Octopress init</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
</span><span class="line">  <span class="nb">system</span> <span class="s2">&quot;git branch -m gh-pages&quot;</span> <span class="k">unless</span> <span class="n">branch</span> <span class="o">==</span> <span class="s1">&#39;master&#39;</span>
</span><span class="line">  <span class="nb">system</span> <span class="s2">&quot;git remote add origin </span><span class="si">#{</span><span class="n">repo_url</span><span class="si">}</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后修改了 <code>Rakefile</code> 中 <code>deploy_default</code> 和 <code>deploy_branch</code> 变量的初始值：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="c1"># deploy 时执行的命令，&quot;push&quot; 为 Rakefile 中定义的一个 rake task</span>
</span><span class="line">  <span class="n">deploy_default</span> <span class="o">=</span> <span class="s2">&quot;push&quot;</span> <span class="c1"># 初始为 &quot;rsync&quot;</span>
</span><span class="line">
</span><span class="line">  <span class="c1"># deploy 时执行上述 rake task 命令 &quot;push&quot; 到 &quot;master&quot; 分支</span>
</span><span class="line">  <span class="n">deploy_branch</span>  <span class="o">=</span> <span class="s2">&quot;master&quot;</span> <span class="c1"># 初始为 &quot;gh-pages&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>再回头来看 <code>rake setup_github_pages</code> ，是不是清晰多了呢？</p>

<h3 id="section">1.3. 生成并部署站点</h3>

<p>执行如下命令，（将 <code>octopress/_deploy</code> 下数据 push 到 <code>master</code> 分支）：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">sudo</span> <span class="n">rake</span> <span class="n">generate</span>
</span><span class="line">  <span class="err">$</span> <span class="n">sudo</span> <span class="n">rake</span> <span class="n">deploy</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这时在浏览器输入 <code>http://username.github.io</code> 就可以访问你的博客网页啦～</p>

<p>最后别忘了 commit 你的 <code>octopress 框架源码</code>到 <code>source</code> 分支：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">git</span> <span class="n">add</span> <span class="o">.</span>
</span><span class="line">  <span class="err">$</span> <span class="n">git</span> <span class="n">commit</span> <span class="o">-</span><span class="n">m</span><span class="s1">&#39;init&#39;</span>  <span class="c1">#init 可随意填写</span>
</span><span class="line">  <span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">source</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>好，到这里，如果顺利完成前面所有内容的话，我们已经将 <code>Octopress</code> 部署到 <code>Github Pages</code> 了。如果你想换成自己的域名可以参考这里的方法（<a href="http://octopress.org/docs/deploying/github/#custom_domains">Custom Domains</a>），不再赘述了。</p>

<p class="info">这里分析下，<code>rake generate</code> 和 <code>rake deploy</code>。</p>

<p>rake generate：生成 <code>jekyll</code> 站点（Generating Site with Jekyll）</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="c1"># 查看 Rakefile</span>
</span><span class="line">  <span class="nb">system</span> <span class="s2">&quot;compass compile --css-dir </span><span class="si">#{</span><span class="n">source_dir</span><span class="si">}</span><span class="s2">/stylesheets&quot;</span>
</span><span class="line">  <span class="nb">system</span> <span class="s2">&quot;jekyll build&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>rake deploy：将站点部署到 <code>Github Pages</code>。由于 <code>_deploy</code> 目录所代表的本地仓库的 <code>master</code> 分支对应 <code>Github Pages</code> 远程仓库的 <code>master</code> 分支，该分支目录的内容即 <code>Github Pages</code> 在互联网上供公开访问的站点内容。因此这里做的主要就是将改动的内容（博客、DIY 布局等…） copy 到 <code>_deploy</code> 目录下，然后将此修改 push 到 <code>Github Pages</code> 远程库的 <code>master</code> 分支。</p>

<ol>
  <li>
    <p>查看是否在 <code>preview-mode</code>(预览模式)，有则删除，重新执行 <code>rake generate</code>；</p>
  </li>
  <li>
    <p>将 <code>octopress/source</code> 目录下的文件拷贝到 <code>octopress/public</code> 目录下；</p>
  </li>
  <li>
    <p>进入 <code>octopress/_deploy</code> 目录，执行 <code>git pull</code> 操作；</p>
  </li>
  <li>
    <p>将 <code>octopress/public</code> 目录的内容拷贝到 <code>octopress/_deploy</code> 目录下；</p>
  </li>
  <li>
    <p>将 <code>octopress/_deploy</code> 目录所对应的本地 <code>master</code> 分支的修改 <code>push</code> 到 <code>Github Pages</code> 远程库的 master 分支。</p>
  </li>
  <li>
    <p>下面可以看到 <code>master</code> 分支 <code>commit</code> 信息格式是 <code>"Site updated at 2015-10-14 12:52:36 UTC"</code> 。</p>
  </li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="c1"># 查看 Rakefile</span>
</span><span class="line">  <span class="nb">system</span> <span class="s2">&quot;git add -A&quot;</span>
</span><span class="line">  <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Site updated at </span><span class="si">#{</span><span class="no">Time</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">utc</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class="line">  <span class="nb">system</span> <span class="s2">&quot;git commit -m </span><span class="se">\&quot;</span><span class="si">#{</span><span class="n">message</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
</span><span class="line">
</span><span class="line">  <span class="c1"># 前面说过 deploy_branch  = &quot;master&quot;</span>
</span><span class="line">  <span class="no">Bundler</span><span class="o">.</span><span class="n">with_clean_env</span> <span class="p">{</span> <span class="nb">system</span> <span class="s2">&quot;git push origin </span><span class="si">#{</span><span class="n">deploy_branch</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-1">二. 发布博文过程</h2>

<h3 id="section-2">2.1. 新建一篇博文</h3>

<p>打开终端，输入：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">cd</span> <span class="n">octopress</span>
</span><span class="line">  <span class="err">$</span> <span class="n">rake</span> <span class="n">new_post</span><span class="o">[</span><span class="s2">&quot;Hi, octopress&quot;</span><span class="o">]</span>  <span class="c1"># &quot;Hi, octopress&quot; 是文章的标题</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后在 <code>octopress/source/_posts</code> 目录下我们会看到命名格式为 <code>"2015-10-14-Hi-octopress.markdown"</code> 的文件。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="c1"># 查看 Rakefile ，这是实现方法</span>
</span><span class="line">  <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">source_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">#{</span><span class="n">posts_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">#{</span><span class="no">Time</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-%d&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"></span>
</span><span class="line"><span class="s2">  </span><span class="si">#{</span><span class="n">title</span><span class="o">.</span><span class="n">to_url</span><span class="si">}</span><span class="s2">.</span><span class="si">#{</span><span class="n">new_post_ext</span><span class="si">}</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>打开新建的 <code>"2015-10-14-Hi-octopress.markdown"</code> 文件（我用的 <a href="http://mouapp.com/">Mou</a>，免费还好用），会发现头文件有如下内容（不要删除这段信息）：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="o">---</span>
</span><span class="line">  <span class="ss">layout</span><span class="p">:</span> <span class="n">post</span>             <span class="c1">#代表是一片博文</span>
</span><span class="line">  <span class="ss">title</span><span class="p">:</span> <span class="s2">&quot;hello world&quot;</span>
</span><span class="line">  <span class="ss">date</span><span class="p">:</span> <span class="mi">2015</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">14</span> <span class="mi">19</span><span class="p">:</span><span class="mi">59</span><span class="p">:</span><span class="mi">22</span> <span class="o">+</span><span class="mi">0800</span>
</span><span class="line">  <span class="ss">comments</span><span class="p">:</span> <span class="kp">true</span>         <span class="c1">#是否允许评论</span>
</span><span class="line">  <span class="ss">categories</span><span class="p">:</span>             <span class="c1">#分类</span>
</span><span class="line">  <span class="o">---</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>头部布局实现原理：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="c1"># 查看 Rakefile，头部布局实现</span>
</span><span class="line">  <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">post</span><span class="o">|</span>
</span><span class="line">  <span class="n">post</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;---&quot;</span>
</span><span class="line">  <span class="n">post</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;layout: post&quot;</span>
</span><span class="line">  <span class="n">post</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;title: </span><span class="se">\&quot;</span><span class="si">#{</span><span class="n">title</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/&amp;/</span><span class="p">,</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
</span><span class="line">  <span class="n">post</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;date: </span><span class="si">#{</span><span class="no">Time</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-%d %H:%M:%S %z&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class="line">  <span class="n">post</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;comments: true&quot;</span>
</span><span class="line">  <span class="n">post</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;categories: &quot;</span>
</span><span class="line">  <span class="n">post</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;---&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在最后面的－－－下面就可以开始我们的正文啦～</p>

<h3 id="section-3">2.2. 预览新建的博文</h3>

<p>终端执行如下命令：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">cd</span> <span class="n">octopress</span>
</span><span class="line">  <span class="err">$</span> <span class="n">sudo</span> <span class="n">rake</span> <span class="n">generate</span>
</span><span class="line">  <span class="err">$</span> <span class="n">rake</span> <span class="n">preview</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在浏览器中打开<a href="http://localhost:4000/">http://localhost:4000</a>,即可以预览我们刚 post 的博客效果。</p>

<h3 id="section-4">2.3. 发布新建的博文</h3>

<p>终端执行：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">sudo</span> <span class="n">rake</span> <span class="n">deploy</span>  <span class="c1">#deploy blog 到 Github Pages</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后别忘了，push 下本地的 octopress 到 source：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">git</span> <span class="n">add</span> <span class="o">.</span>
</span><span class="line">  <span class="err">$</span> <span class="n">git</span> <span class="n">commit</span> <span class="o">-</span><span class="n">m</span><span class="s1">&#39;post test blog&#39;</span>
</span><span class="line">  <span class="err">$</span> <span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">source</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>OK，到此，本地 octopress 博客部署到 Github Pages 完成了，打开访问你的个人博客看看效果吧。额，因为还没有做布局修改，留到下一篇介绍～</p>

<p class="info">部署这一块，自己花了挺长时间研究的，大体上理清了自己之前在做时的一些疑问。现在回头再看 Github 上的目录和本地的目录，一下子明朗了不少。不知道你是不是也觉得呢？</p>

<blockquote>
  <p>本篇参考：</p>

  <p><a href="http://octopress.org/docs/deploying/github/#custom_domains">Deploying to Github Pages</a></p>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于 Octopress & Github Pages 搭建博客（一）]]></title>
    <link href="http://jonyfang.com/blog/2015/10/13/starting_blog_with_octopress_1/"/>
    <updated>2015-10-13T13:13:00+08:00</updated>
    <id>http://jonyfang.com/blog/2015/10/13/starting_blog_with_octopress_1</id>
    <content type="html"><![CDATA[<p class="info">一直以来想有个属于自己的博客空间，或许是出于一种归属感吧。就这样知道了 WordPress、Jekyll、Hexo 和 Octopress。一番对比后选择了 Octopress，相信追随大神的脚步应该不会错。Octopress 接触有一个多星期了，幸运的是经过一番折腾算是弄出点了模样。这里总结下 <strong><code>基于 Octopress 及 Github 搭建博客</code></strong> 的过程及自己 <strong><code>中间遇到的一些问题的解决办法</code></strong>。技术上不一定完全精确，若有大神围观望指正：)
<br /><br />
使用的是 Mac OS X 系统，不一定适用于 Windows 的童鞋。（勿拍砖…）
<br /><br />
这是最终的实现效果：<a href="http://jonyfang.github.io/" target="_blank"> I’m Jony</a></p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#octopress--jekyll--github-pages-" id="markdown-toc-octopress--jekyll--github-pages-">一. Octopress 与 Jekyll &amp; Github Pages 的关系</a></li>
  <li><a href="#section" id="markdown-toc-section">二. 准备工作</a>    <ul>
      <li><a href="#git" id="markdown-toc-git">2.1. 安装 Git</a></li>
      <li><a href="#ruby" id="markdown-toc-ruby">2.2. 安装 Ruby</a></li>
    </ul>
  </li>
  <li><a href="#octopress" id="markdown-toc-octopress">三. 本地安装 Octopress</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">四. 预览效果</a></li>
</ul>

<h2 id="octopress--jekyll--github-pages-">一. Octopress 与 Jekyll &amp; Github Pages 的关系</h2>

<p><code>Octopress</code> 是基于 <code>Jekyll</code> 的静态博客框架。</p>

<p><code>GitHub Pages</code> 这里用于显示托管在 <code>GitHub</code> 上的静态网页，是 GitHub 提供的一项服务。</p>

<p>总的来说也就是我们使用基于 <code>Jekyll</code> 的 <code>Octopress</code> 生成本地的静态网站，然后将静态的网站托管到 <code>Github</code> 为我们提供的 <code>Github Pages</code> 服务上。最后访问<code>博客地址</code>就可以显示我们的个人博客网站了。</p>

<h2 id="section">二. 准备工作</h2>

<h3 id="git">2.1. 安装 Git</h3>

<p>前往 Git 官网 <a href="http://git-scm.com/">点击这里</a> ，按下图提示下载安装（一般 Mac OS X自带 Git 环境，终端执行 git -v 可查看 Git 版本）。</p>

<p><img src="http://jonyfang.github.io/images/octopress/git_downloads.png" alt="git_downloads" /></p>

<h3 id="ruby">2.2. 安装 Ruby</h3>

<p>这是 <a href="https://www.ruby-lang.org/en/">Ruby 官网</a>，这里就不详细介绍 Ruby 啦，总之 Ruby 很 NB，后面静下心研究下。好吧，回到 Ruby 的安装。</p>

<p>打开终端，执行如下命令，<code>安装 RVM</code>，同时也会安装最新的 Ruby：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">curl</span> <span class="o">-</span><span class="n">L</span> <span class="ss">https</span><span class="p">:</span><span class="sr">//</span><span class="n">get</span><span class="o">.</span><span class="n">rvm</span><span class="o">.</span><span class="n">io</span> <span class="o">|</span> <span class="n">bash</span> <span class="o">-</span><span class="n">s</span> <span class="n">stable</span> <span class="o">--</span><span class="n">ruby</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>安装完，执行如下命令，<code>查看 Ruby 版本</code> (-v = –version)</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">ruby</span> <span class="o">-</span><span class="n">v</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果你的 Ruby 版本不低于 <code>1.9.3</code>，可直接跳转到 <code>安装 RubyGems</code>。否则需要执行如下命令：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">rvm</span> <span class="n">install</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span>
</span><span class="line">  <span class="err">$</span> <span class="n">rvm</span> <span class="n">use</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>安装 RubyGems：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">rvm</span> <span class="n">rubygems</span> <span class="n">latest</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在我们再执行命令 <code>ruby -v</code> 查看 Ruby版本，会看到现在已经是 2.0.0 了。</p>

<p>呼，准备工作搞定！</p>

<h2 id="octopress">三. 本地安装 Octopress</h2>

<p>前面做了那么多准备，主角总算要上场了。</p>

<p>首先，将 Octopress 的项目 <code>clone</code> 到本地，终端执行如下命令：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">git</span> <span class="nb">clone</span> <span class="ss">git</span><span class="p">:</span><span class="sr">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">imathis</span><span class="o">/</span><span class="n">octopress</span><span class="o">.</span><span class="n">git</span> <span class="n">octopress</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>进入 octopress 目录，安装 Octopress 所需要的<code>依赖库（dependencies）</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">cd</span> <span class="n">octopress</span>
</span><span class="line">
</span><span class="line">  <span class="c1"># 安装过程中可能会遇到权限问题，我们需要在命令前面加上 sudo 再执行，并输入登录密码。</span>
</span><span class="line">  <span class="c1"># sudo 全称：super user do，也就是以 root 用户身份来执行</span>
</span><span class="line">
</span><span class="line">  <span class="err">$</span> <span class="n">sudo</span> <span class="n">gem</span> <span class="n">install</span> <span class="n">bundler</span>
</span><span class="line">  <span class="err">$</span> <span class="n">bundle</span> <span class="n">install</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p class="warning">这里在不翻墙的情况下，可能会遇到一个问题：<code>sudo gem install bundler</code> 执行后，一直没有响应。这是由于国内网络原因（你懂的），导致<a href="http://rubygems.org/" target="_blank"> rubygems.org </a>存放在 <code>Amazon S3</code> 上面的资源文件间歇性连接失败。所以你会遇到 <code>gem install rack</code> 或 <code>bundle install</code> 的时候半天没有响应的情况。</p>

<p>幸运的是国内某大神帮我们解决了这一心头大患，我们可以用<code>淘宝的 Ruby 镜像</code>来替换原来的镜像。只需终端执行下面的命令即可：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">gem</span> <span class="n">sources</span> <span class="o">-</span><span class="n">a</span> <span class="ss">https</span><span class="p">:</span><span class="sr">//</span><span class="n">ruby</span><span class="o">.</span><span class="n">taobao</span><span class="o">.</span><span class="n">org</span><span class="o">/</span> <span class="o">-</span><span class="n">r</span> <span class="ss">https</span><span class="p">:</span><span class="sr">//</span><span class="n">rubygems</span><span class="o">.</span><span class="n">org</span><span class="o">/</span>
</span><span class="line">
</span><span class="line">  <span class="c1"># 下一命令查看切换后结果</span>
</span><span class="line">  <span class="err">$</span> <span class="n">gem</span> <span class="n">sources</span> <span class="o">-</span><span class="n">l</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后会看到这样的输出：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="o">***</span> <span class="no">CURRENT</span> <span class="no">SOURCES</span> <span class="o">***</span>
</span><span class="line">
</span><span class="line">  <span class="ss">https</span><span class="p">:</span><span class="sr">//</span><span class="n">ruby</span><span class="o">.</span><span class="n">taobao</span><span class="o">.</span><span class="n">org</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这就说明我们切换到<code>淘宝的 Ruby 镜像</code>了，再次安装 Octopress 所需要的依赖库就会发现现在可以了。</p>

<p>最后安装下默认主题：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="c1"># rake 全称：ruby make</span>
</span><span class="line">  <span class="err">$</span> <span class="n">rake</span> <span class="n">install</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p class="addition">上面提到的 <code>Ruby 镜像</code>问题，还有另外两种解决方法:
<br /><br />
（1）比较原始的方法——手动更改：打开 <code>octopress</code> 文件夹 -&gt; 打开 <code>Gemfile</code> 文件 -&gt; 将 <code>source "https://rubygems.org"</code> 改为 <code>source "https://ruby.taobao.org"</code> 就可以了。
<br /><br />
（2）第二种相对方便点，因为我们使用的是 Gemfile，所以我们可以用 Bundler 的 <a href="http://bundler.io/v1.5/bundle_config.html#gem-source-mirrors">Gem 源代码镜像命令</a>，这样我们就不用改 Gemfile 的 source 了。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">cd</span> <span class="n">octopress</span>
</span><span class="line">  <span class="err">$</span> <span class="n">bundle</span> <span class="n">config</span> <span class="n">mirror</span><span class="o">.</span><span class="n">https</span><span class="ss">:/</span><span class="o">/</span><span class="n">rubygems</span><span class="o">.</span><span class="n">org</span> <span class="ss">https</span><span class="p">:</span><span class="sr">//</span><span class="n">ruby</span><span class="o">.</span><span class="n">taobao</span><span class="o">.</span><span class="n">org</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-1">四. 预览效果</h2>

<p>好，经过上面的功夫，我们已经在本地搭建了一个简易版的 Octopress 博客。</p>

<p>我们来看看效果吧。在终端执行命令：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line">  <span class="err">$</span> <span class="n">sudo</span> <span class="n">rake</span> <span class="n">preview</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>打开浏览器，输入 <code>http://localhost:4000/</code>，就可以看到效果了。虽然比较简陋，但让人挺高兴的，你觉得呢？</p>

<p><img src="http://jonyfang.github.io/images/octopress/octo_newpage.png" alt="octopress 本地显示效果" /></p>

<p>到这里，我们算是初步结束了本地安装过程，下一篇我们会把<code>本地的 Octopress</code> 部署到 <code>Github</code>，那么下篇再见喽～</p>

<blockquote>
  <p>本篇参考：</p>

  <p><a href="http://octopress.org/docs/setup/">Octopress Setup</a></p>

  <p><a href="http://bundler.io/v1.5/bundle_config.html#gem-source-mirrors">Gem Source Mirrors</a></p>
</blockquote>
]]></content>
  </entry>
  
</feed>
