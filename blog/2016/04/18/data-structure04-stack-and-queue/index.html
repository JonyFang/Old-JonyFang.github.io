
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>数据结构浅析（四）：栈和队列 - I'm Jony</title>
  <meta name="author" content="Jony Fang">

  
  <meta name="description" content="什么是栈？
栈有哪些存储方式？
栈有哪些应用？ 什么是队列？
队列有哪些存储方式？ 本篇总结了这几个问题 1.栈 1.1.栈的定义 1.2.	栈的顺序存储结构及实现 1.3.两栈共享空间 1.4.栈的链式存储结构（链栈）及实现 2.栈的应用－－递归 2.1.斐波那契数列（Fibonacci）实现 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jonyfang.com/blog/2016/04/18/data-structure04-stack-and-queue/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="I'm Jony" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="/stylesheets/fonts/fonts_custom.css" rel="stylesheet" type="text/css">
<link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-69029852-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">I'm Jony</a></h1>
  
    <h2>人生如长跑，成长如进阶</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="jonyfang.com">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">文章列表</a></li>
  <li><a href="/tags">标签</a></li>
  <li><a href="/about/index.html">关于我</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">数据结构浅析（四）：栈和队列</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-04-18T14:30:23+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:30 pm</span></time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://jonyfang.com">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p class="info">什么是栈？
栈有哪些存储方式？
栈有哪些应用？
<br />
什么是队列？
队列有哪些存储方式？
<br />
本篇总结了这几个问题</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1.栈</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">1.1.栈的定义</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">1.2.	栈的顺序存储结构及实现</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">1.3.两栈共享空间</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">1.4.栈的链式存储结构（链栈）及实现</a></li>
    </ul>
  </li>
  <li><a href="#section-5" id="markdown-toc-section-5">2.栈的应用－－递归</a>    <ul>
      <li><a href="#fibonacci" id="markdown-toc-fibonacci">2.1.斐波那契数列（Fibonacci）实现</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">2.2.递归定义</a></li>
    </ul>
  </li>
  <li><a href="#section-7" id="markdown-toc-section-7">3.栈的应用－－四则运算表达式求值</a>    <ul>
      <li><a href="#section-8" id="markdown-toc-section-8">3.1.后缀（逆波兰）表示法应用</a></li>
      <li><a href="#section-9" id="markdown-toc-section-9">3.2.中缀表达式转后缀表达式</a></li>
    </ul>
  </li>
  <li><a href="#section-10" id="markdown-toc-section-10">4.队列</a>    <ul>
      <li><a href="#section-11" id="markdown-toc-section-11">4.1.队列定义</a></li>
      <li><a href="#section-12" id="markdown-toc-section-12">4.2.循环对列</a>        <ul>
          <li><a href="#section-13" id="markdown-toc-section-13">4.2.1.循环对列</a></li>
          <li><a href="#section-14" id="markdown-toc-section-14">4.2.2.对列的链式存储结构及实现</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-15" id="markdown-toc-section-15">5.总结</a></li>
</ul>

<!-- more -->

<h1 id="section">1.栈</h1>

<h2 id="section-1">1.1.栈的定义</h2>

<p>栈（stack）是限定仅在表尾（栈顶 top）进行插入和删除操作的后进先出的线性表。</p>

<p>push、pop 操作在栈顶进行。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">ADT 栈(stack)
</span><span class="line">Data
</span><span class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
</span><span class="line">Operation
</span><span class="line">    InitStack(*S):    初始化操作，建立一个空栈S。
</span><span class="line">    DestroyStack(*S): 若栈存在，则销毁它。
</span><span class="line">    ClearStack(*S):   将栈清空。
</span><span class="line">    StackEmpty(S):    若栈为空，返回true，否则返回false。
</span><span class="line">    GetTop(S, *e):    若栈存在且非空，用e返回S的栈顶元素。
</span><span class="line">    Push(*S, e):      若栈S存在，插入新元素e到栈S中并成为栈顶元素。
</span><span class="line">    Pop(*S, *e):      删除栈S中栈顶元素，并用e返回其值。
</span><span class="line">    StackLength(S):   返回栈S的元素个数。
</span><span class="line">endADT</span></code></pre></td></tr></table></div></figure></notextile></div>

<hr />

<h2 id="section-2">1.2.	栈的顺序存储结构及实现</h2>

<p>栈的结构定义</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* SElemType类型根据实际情况而定，这里假设为int */
</span><span class="line">typedef int SElemType;    
</span><span class="line">typedef struct
</span><span class="line">{
</span><span class="line">    SElemType data[MAXSIZE];
</span><span class="line">    /* 用于栈顶指针 */
</span><span class="line">    int top;              
</span><span class="line">}SqStack; </span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E6%A0%88%E6%99%AE%E9%80%9A3%E7%A7%8D%E7%8A%B6%E6%80%81.png" alt="栈普通3种状态" /></p>

<p>现在有一个栈，StackSize是5，则栈普通情况、空栈和栈满的情况、空栈和栈满的情况示意图如上</p>

<p>进栈(push)：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 插入元素e为新的栈顶元素 */
</span><span class="line">Status Push(SqStack *S, SElemType e)
</span><span class="line">{
</span><span class="line">    /* 栈满 */
</span><span class="line">    if (S-&gt;top == MAXSIZE - 1)    
</span><span class="line">    {
</span><span class="line">        return ERROR;
</span><span class="line">    }
</span><span class="line">    /* 栈顶指针增加一 */
</span><span class="line">    S-&gt;top++;                     
</span><span class="line">    /* 将新插入元素赋值给栈顶空间 */
</span><span class="line">    S-&gt;data[S-&gt;top] = e;          
</span><span class="line">    
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>出栈(pop):</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，
</span><span class="line">   并返回OK；否则返回ERROR */
</span><span class="line">Status Pop(SqStack *S, SElemType *e)
</span><span class="line">{
</span><span class="line">    if (S-&gt;top == -1)
</span><span class="line">        return ERROR;
</span><span class="line">    /* 将要删除的栈顶元素赋值给e */
</span><span class="line">    *e = S-&gt;data[S-&gt;top];    
</span><span class="line">    /* 栈顶指针减一 */
</span><span class="line">    S-&gt;top--;  
</span><span class="line">                  
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>
<hr />

<h2 id="section-3">1.3.两栈共享空间</h2>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4.png" alt="两栈共享空间" /></p>

<p>数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为数组的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。（只针对两个具有相同数据类型的栈）</p>

<p>栈1为空时，即top1等于-1时；栈2为空时，即top2等于n时；栈满时，即top1+1==top2时。</p>

<p>两栈共享空间的结构的代码:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 两栈共享空间结构 */
</span><span class="line">typedef struct
</span><span class="line">{
</span><span class="line">    SElemType data[MAXSIZE];
</span><span class="line">    int top1;    /* 栈1栈顶指针 */
</span><span class="line">    int top2;    /* 栈2栈顶指针 */
</span><span class="line">} SqDoubleStack;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于两栈共享空间的push方法，除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber。插入元素的代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 插入元素e为新的栈顶元素 */
</span><span class="line">Status Push(SqDoubleStack *S, SElemType e, 
</span><span class="line">int stackNumber)
</span><span class="line">{
</span><span class="line">    /* 栈已满，不能再push新元素了 */
</span><span class="line">    if (S-&gt;top1 + 1 == S-&gt;top2)    
</span><span class="line">        return ERROR;
</span><span class="line">    /* 栈1有元素进栈 */
</span><span class="line">    if (stackNumber == 1)          
</span><span class="line">        /* 若栈1则先top1+1后给数组元素赋值 */
</span><span class="line">        S-&gt;data[++S-&gt;top1] = e;    
</span><span class="line">    /* 栈2有元素进栈 */
</span><span class="line">    else if (stackNumber == 2)     
</span><span class="line">        /* 若栈2则先top2-1后给数组元素赋值 */
</span><span class="line">        S-&gt;data[--S-&gt;top2] = e;    
</span><span class="line">        
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于两栈共享空间的pop方法，参数就只是判断栈1栈2的参数stackNumber，代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，
</span><span class="line">   并返回OK；否则返回ERROR */
</span><span class="line">Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber)
</span><span class="line">{
</span><span class="line">    if (stackNumber == 1)
</span><span class="line">    {
</span><span class="line">        /* 说明栈1已经是空栈，溢出 */
</span><span class="line">        if (S-&gt;top1 == -1)
</span><span class="line">            return ERROR;
</span><span class="line">        /* 将栈1的栈顶元素出栈 */
</span><span class="line">        *e = S-&gt;data[S-&gt;top1--];    
</span><span class="line">    }
</span><span class="line">    else if (stackNumber == 2)
</span><span class="line">    {
</span><span class="line">        /* 说明栈2已经是空栈，溢出 */
</span><span class="line">        if (S-&gt;top2 == MAXSIZE)
</span><span class="line">            return ERROR;           
</span><span class="line">        /* 将栈2的栈顶元素出栈 */
</span><span class="line">        *e = S-&gt;data[S-&gt;top2++];    
</span><span class="line">    }
</span><span class="line">    
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-4">1.4.栈的链式存储结构（链栈）及实现</h2>

<p>链栈的结构代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">typedef struct StackNode
</span><span class="line">{
</span><span class="line">    SElemType data;
</span><span class="line">    struct StackNode *next;
</span><span class="line">} StackNode, *LinkStackPtr;
</span><span class="line">
</span><span class="line">typedef struct LinkStack
</span><span class="line">{
</span><span class="line">    LinkStackPtr top;
</span><span class="line">    int count;
</span><span class="line">} LinkStack;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>进栈：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 插入元素e为新的栈顶元素 */
</span><span class="line">Status Push(LinkStack *S, SElemType e)
</span><span class="line">{
</span><span class="line">    LinkStackPtr s 
</span><span class="line">      = (LinkStackPtr)malloc(sizeof(StackNode));
</span><span class="line">    s-&gt;data = e;
</span><span class="line">    /* 把当前的栈顶元素赋值给新结点的直接后继，如图中① */
</span><span class="line">    s-&gt;next = S-&gt;top;    
</span><span class="line">    /* 将新的结点s赋值给栈顶指针，如图中② */
</span><span class="line">    S-&gt;top = s;          
</span><span class="line">    S-&gt;count++;
</span><span class="line">    
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>出栈：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，
</span><span class="line">   并返回OK；否则返回ERROR */
</span><span class="line">Status Pop(LinkStack *S, SElemType *e)
</span><span class="line">{
</span><span class="line">    LinkStackPtr p;
</span><span class="line">    if (StackEmpty(*S))
</span><span class="line">        return ERROR;
</span><span class="line">    *e = S-&gt;top-&gt;data;
</span><span class="line">    /* 将栈顶结点赋值给p，如图③ */
</span><span class="line">    p = S-&gt;top;               
</span><span class="line">    /* 使得栈顶指针下移一位，指向后一结点，如图④ */
</span><span class="line">    S-&gt;top = S-&gt;top-&gt;next;    
</span><span class="line">    /* 释放结点p */
</span><span class="line">    free(p);                  
</span><span class="line">    S-&gt;count--;
</span><span class="line">    
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<hr />

<h1 id="section-5">2.栈的应用－－递归</h1>

<h2 id="fibonacci">2.1.斐波那契数列（Fibonacci）实现</h2>

<p>问：如果兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔都不死，那么一年以后可以繁殖多少对兔子呢？</p>

<p>分析：拿新出生的一对小兔子分析一下：第一个月小兔子没有繁殖能力，所以还是一对；两个月后，生下一对小兔子数共有两对；三个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，所以一共是三对……</p>

<p>依次类推可以列出下表：</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-tuzi.png" alt="" /></p>

<p>表中数字1，1，2，3，5，8，13……构成了一个序列。这个数列有个十分明显的特点，前面相邻两项之和，构成了后一项</p>

<p>如下图：
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E4%B8%A4%E9%A1%B9%E4%B9%8B%E5%92%8C%EF%BC%9D%E4%B8%8B%E4%B8%80%E9%A1%B9.png" alt="" /></p>

<p>对应的数学函数：
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%85%94%E5%AD%90%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="" /></p>

<p>打印出前40位的斐波那契数列数:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int main()
</span><span class="line">{
</span><span class="line">    int i;
</span><span class="line">    int a[40];
</span><span class="line">    a[0] = 0;
</span><span class="line">    a[1] = 1;
</span><span class="line">    printf("%d ", a[0]);
</span><span class="line">    printf("%d ", a[1]);
</span><span class="line">    for (i = 2; i &lt; 40; i++)
</span><span class="line">    {
</span><span class="line">        a[i] = a[i - 1] + a[i - 2];
</span><span class="line">        printf("%d ", a[i]);
</span><span class="line">    }
</span><span class="line">    return 0;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>其实我们的代码，如果用递归来实现，还可以更简单:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 斐波那契的递归函数 */ 
</span><span class="line">int Fbi(int i)
</span><span class="line">{
</span><span class="line">    if (i &lt; 2)
</span><span class="line">        return i == 0 ? 0 : 1;
</span><span class="line">    /* 这里Fbi就是函数自己，它在调用自己 */
</span><span class="line">    return Fbi(i - 1) + Fbi(i - 2);    
</span><span class="line">}
</span><span class="line">int main()
</span><span class="line">{
</span><span class="line">    int i;
</span><span class="line">    for (i = 0; i &lt; 40; i++)
</span><span class="line">        printf("%d ", Fbi(i));
</span><span class="line">    return  0;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>相比较迭代的代码，是不是干净很多。
那么这段递归是怎么执行的呢？我们来模拟代码种的 Fbi(i) 函数当 i=5 的执行过程，如下图：</p>

<p><img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_Fbi(5)%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Fbi(5)执行过程" /></p>

<h2 id="section-6">2.2.递归定义</h2>

<p>迭代和递归的区别是：
迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。</p>

<p>递归与栈有什么关系？
这得从计算机系统的内部说起，前面我们已经看到递归是如何执行它的前行(Fbi(i))和退回(return)阶段的。递归过程退回的顺序是它前行顺序的逆序。在退回过程中，可能要执行某些动作，包括恢复在前行过程中存储起来的某些数据。</p>

<p>这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合栈这样的数据结构，因此，编译器使用栈实现递归就没什么好惊讶的了。</p>

<p>简单的说，就是在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。</p>

<h1 id="section-7">3.栈的应用－－四则运算表达式求值</h1>

<h2 id="section-8">3.1.后缀（逆波兰）表示法应用</h2>

<p>对于“9+(3-1)×3+10÷2”，如果要用后缀表示法应该是什么样子：“9 3 1-3*+102/+”，这样的表达式称为后缀表达式，叫后缀的原因在于所有的符号都是在要运算数字的后面出现。</p>

<p>举例：
后缀表达式：9 3 1-3*+10 2/+</p>

<p>规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p>

<p>1．初始化一个空栈。此栈用来对要运算的数字进出使用；
2．后缀表达式中前三个都是数字，所以9、3、1进栈；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F01.png" alt="" />
3．接下来是“-”，所以将栈中的1出栈作为减数，3出栈作为被减数，并运算3-1得到2，再将2进栈；
4．接着是数字3进栈；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F02.png" alt="" />
5．后面是“*”，也就意味着栈中3和2出栈，2与3相乘，得到6，并将6进栈；
6．下面是“+”，所以栈中6和9出栈，9与6相加，得到15，将15进栈；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F03.png" alt="" />
7．接着是10与2两数字进栈；
8．接下来是符号“/”，因此，栈顶的2与10出栈，10与2相除，得到5，将5进栈；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F04.png" alt="" />
9．最后一个是符号“+”，所以15与5出栈并相加，得到20，将20进栈，如图4-9-5的左图所示。10．结果是20出栈，栈变为空
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F05.png" alt="" /></p>

<p>很顺利的解决了计算的问题，那么如何让“9+(3-1)×3+10÷2”转化为“9 3 1-3+10 2/+”呢？</p>

<h2 id="section-9">3.2.中缀表达式转后缀表达式</h2>

<p>“9+(3-1)×3+10÷2”这样平时所用的标准四则运算表达式，因为所有的运算符号都在两数字之间，所以叫做中缀表达式。</p>

<p>中缀表达式“9+(3-1)×3+10÷2”转化为后缀表达式“9 3 1-3*+10 2/+”</p>

<p>规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</p>

<p>1．初始化一空栈，用来对符号进出栈使用；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F01.png" alt="" />
2．第一个字符是数字9，输出9，后面是符号“+”，进栈；
3．第三个字符是“(”，依然是符号，因其只是左括号，还未配对，故进栈；
4．第四个字符是数字3，输出，总表达式为93，接着是“-”，进栈；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F02.png" alt="" />
5．接下来是数字1，输出，总表达式为 9 31，后面是符号“)”，此时，我们需要去匹配此前的“(”，所以栈顶依次出栈，并输出，直到“(”出栈为止。此时左括号上方只有“-”，因此输出“-”。总的输出表达式为 9 3 1-；
6．紧接着是符号“×”，因为此时的栈顶符号为“+”号，优先级低于“×”，因此不输出，“<em>”进栈。接着是数字3，输出，总的表达式为 9 3 1-3；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F03.png" alt="" />
7．之后是符号“+”，此时当前栈顶元素“”比这个“+”的优先级高，因此栈中元素出栈并输出（没有比“+”号更低的优先级，所以全部出栈），总输出表达式为9 3 1-3+。然后将当前这个符号“+”进栈。也就是说，前6张图的栈底的“+”是指中缀表达式中开头的9后面那个“+”，而图4-9-9左图中的栈底（也是栈顶）的“+”是指“9+(3-1)×3+”中的最后一个“+”；
8．紧接着数字10，输出，总表达式变为9 31-3</em>+10。后是符号“÷”，所以“/”进栈；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F04.png" alt="" />
9．最后一个数字2，输出，总的表达式为9 31-3+10 2。如图4-9-10的左图所示。10．因已经到最后，所以将栈中符号全部出栈并输出。最终输出的后缀表达式结果为93 1-3+10 2/+”；
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F05.png" alt="" /></p>

<hr />

<h1 id="section-10">4.队列</h1>

<h2 id="section-11">4.1.队列定义</h2>

<p>队列（queue）是一种先进先出（First In First Out）的线性表，简称FIFO。只允许在一端进行插入操作，而在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">ADT 队列(Queue)
</span><span class="line">Data
</span><span class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
</span><span class="line">Operation
</span><span class="line">    InitQueue(*Q):    初始化操作，建立一个空队列Q。
</span><span class="line">    DestroyQueue(*Q): 若队列Q存在，则销毁它。
</span><span class="line">    ClearQueue(*Q):   将队列Q清空。
</span><span class="line">    QueueEmpty(Q):    若队列Q为空，返回true，否则返回false。
</span><span class="line">    GetHead(Q, *e):   若队列Q存在且非空，用e返回队列Q的队头元素。
</span><span class="line">    EnQueue(*Q, e):   若队列Q存在，插入新元素e到队列Q中并成为队尾元素。
</span><span class="line">    DeQueue(*Q, *e):  删除队列Q中队头元素，并用e返回其值。
</span><span class="line">    QueueLength(Q):   返回队列Q的元素个数
</span><span class="line">endADT</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-12">4.2.循环对列</h2>

<h3 id="section-13">4.2.1.循环对列</h3>

<p>首先了解下，什么是假溢出：
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%BE%AA%E7%8E%AF%E5%AF%B9%E5%88%9701.png" alt="" />
假设这个队列的总个数不超过5个，但目前如果接着入队的话，因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上，我们的队列在下标为0和1的地方还是空闲的。我们把这种现象叫做“假溢出”。</p>

<p>解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。这种头尾相接的顺序存储结构就是循环队列。</p>

<p>此时问题出来了，空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？</p>

<ul>
  <li>办法一是设置一个标志变量flag，当front==rear，且flag=0时为队列空，当front==rear，且flag=1时为队列满。</li>
  <li>办法二是当队列空时，条件就是front=rear，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。例如图4-12-8所示，我们就认为此队列已经满了，也就是说，我们不允许图4-12-7的右图情况出现。
<img src="http://7xob7d.com1.z0.glb.clouddn.com/stack_and_queue_%E5%BE%AA%E7%8E%AF%E5%AF%B9%E5%88%9702.png" alt="" /></li>
</ul>

<p>问题又来了，第二种方法，由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。
若队列的最大尺寸为QueueSize，那么队列满的条件是(rear+1)%QueueSize==front（取模“%”的目的就是为了整合rear与front大小为一个问题）。</p>

<p>另外，当rear&gt;front时，此时队列的长度为rear-front。但当rear&lt;front时，队列长度分为两段，一段是QueueSize-front，另一段是0+rear，加在一起，队列长度为rear-front+QueueSize。
因此通用的计算队列长度公式为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(rear-front+QueueSize)%QueueSize</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>有了这些讲解，现在实现循环队列就不难了。</p>

<p>循环队列的顺序存储结构代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* QElemType类型根据实际情况而定，这里假设为int */
</span><span class="line">typedef int QElemType;    
</span><span class="line">/* 循环队列的顺序存储结构 */
</span><span class="line">typedef struct
</span><span class="line">{
</span><span class="line">    QElemType data[MAXSIZE];
</span><span class="line">    /* 头指针 */
</span><span class="line">    int front;            
</span><span class="line">    /* 尾指针，若队列不空，
</span><span class="line">       指向队列尾元素的下一个位置 */
</span><span class="line">    int rear;             
</span><span class="line">} SqQueue;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>循环队列的初始化代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 初始化一个空队列Q */
</span><span class="line">Status InitQueue(SqQueue *Q)
</span><span class="line">{
</span><span class="line">    Q-&gt;front = 0;
</span><span class="line">    Q-&gt;rear = 0;    
</span><span class="line">    
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>循环队列求队列长度代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 返回Q的元素个数，也就是队列的当前长度 */
</span><span class="line">int QueueLength(SqQueue Q)
</span><span class="line">{
</span><span class="line">    return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>循环队列的入队列操作代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 若队列未满，则插入元素e为Q新的队尾元素 */
</span><span class="line">Status EnQueue(SqQueue *Q, QElemType e)
</span><span class="line">{
</span><span class="line">    /* 队列满的判断 */
</span><span class="line">    if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)    
</span><span class="line">        return ERROR;
</span><span class="line">    /* 将元素e赋值给队尾 */
</span><span class="line">    Q-&gt;data[Q-&gt;rear] = e;                       
</span><span class="line">    /* rear指针向后移一位置， */
</span><span class="line">    Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;          
</span><span class="line">    /* 若到最后则转到数组头部 */
</span><span class="line">    
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>循环队列的出队列操作代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 若队列不空，则删除Q中队头元素，用e返回其值 */
</span><span class="line">Status DeQueue(SqQueue *Q, QElemType *e)
</span><span class="line">{
</span><span class="line">    /* 队列空的判断 */
</span><span class="line">    if (Q-&gt;front == Q-&gt;rear)                
</span><span class="line">        return ERROR;
</span><span class="line">    /* 将队头元素赋值给e */
</span><span class="line">    *e = Q-&gt;data[Q-&gt;front];                 
</span><span class="line">    /* front指针向后移一位置， */
</span><span class="line">    Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;    
</span><span class="line">    /* 若到最后则转到数组头部 */
</span><span class="line">    return  OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>到这里可以看出单是顺序存储，若不是循环队列，算法的时间性能是不高的，但循环队列又面临着数组可能会溢出的问题，所以我们还需要研究一下不需要担心队列长度的链式存储结构。</p>

<h3 id="section-14">4.2.2.对列的链式存储结构及实现</h3>

<p>链对列的结构：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* QElemType类型根据实际情况而定，这里假设为int */
</span><span class="line">typedef int QElemType;       
</span><span class="line">/* 结点结构 */
</span><span class="line">typedef struct QNode         
</span><span class="line">{
</span><span class="line">    QElemType data;
</span><span class="line">    struct QNode *next;
</span><span class="line">} QNode, *QueuePtr;
</span><span class="line">
</span><span class="line">/* 队列的链表结构 */
</span><span class="line">typedef struct               
</span><span class="line">{
</span><span class="line">    /* 队头、队尾指针 */
</span><span class="line">    QueuePtr front, rear;    
</span><span class="line">} LinkQueue;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>入对列：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 插入元素e为Q的新的队尾元素 */
</span><span class="line">Status EnQueue(LinkQueue *Q, QElemType e)
</span><span class="line">{
</span><span class="line">    QueuePtr s = 
</span><span class="line">(QueuePtr)malloc(sizeof(QNode));
</span><span class="line">    /* 存储分配失败 */
</span><span class="line">    if (!s)               
</span><span class="line">        exit(OVERFLOW);
</span><span class="line">    s-&gt;data = e;
</span><span class="line">    s-&gt;next = NULL;
</span><span class="line">    /* 把拥有元素e新结点s赋值给原队尾结点的后继， */
</span><span class="line">    Q-&gt;rear-&gt;next = s;    
</span><span class="line">    /* 见上图中① */
</span><span class="line">    /* 把当前的s设置为队尾结点，rear指向s，见上图中② */
</span><span class="line">    Q-&gt;rear = s;  
</span><span class="line">            
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>出对列：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/* 若队列不空，删除Q的队头元素，用e返回其值，
</span><span class="line">并返回OK，否则返回ERROR */
</span><span class="line">Status DeQueue(LinkQueue *Q, QElemType *e)
</span><span class="line">{
</span><span class="line">    QueuePtr p;
</span><span class="line">    if (Q-&gt;front == Q-&gt;rear)
</span><span class="line">        return ERROR;
</span><span class="line">    /* 将欲删除的队头结点暂存给p，见上图中① */
</span><span class="line">    p = Q-&gt;front-&gt;next;          
</span><span class="line">    /* 将欲删除的队头结点的值赋值给e */
</span><span class="line">    *e = p-&gt;data;                
</span><span class="line">    /* 将原队头结点后继p-&gt;next赋值给头结点后继， */
</span><span class="line">    Q-&gt;front-&gt;next = p-&gt;next;    
</span><span class="line">    /* 见上图中② */
</span><span class="line">    /* 若队头是队尾，则删除后将rear指向头结点，见上图中③ */
</span><span class="line">    if (Q-&gt;rear == p)            
</span><span class="line">        Q-&gt;rear = Q-&gt;front;
</span><span class="line">    free(p);
</span><span class="line">    return OK;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于循环队列与链队列的比较，可以从两方面来考虑，从时间上，其实它们的基本操作都是常数时间，即都为O(1)的，不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。</p>

<p>总的来说，在可以确定队列长度最大值的情况下，可以用循环队列，如果无法预估队列的长度时，则用链队列。</p>

<hr />

<h1 id="section-15">5.总结</h1>
<p>栈（stack）是限定仅在表尾进行插入和删除操作的线性表。</p>

<p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>

<p>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。因此它们各自有各自的技巧来解决这个问题。</p>

<p>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。</p>

<p>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Jony Fang</span></span>

      




<time class='entry-date' datetime='2016-04-18T14:30:23+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:30 pm</span></time>
      


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/01/10/data_structure03.linear_list/" title="Previous Post: 数据结构浅析（三）：线性表">&laquo; 数据结构浅析（三）：线性表</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Jony Fang</h1>
  <p>爱折腾，爱跑步，爱那些让人感觉美好的事物</p>
  <p>目前是一名学生，同时也是一名忠诚的 iOS 开发者。但为眼前事，踏实前行，不忘初心就好。</p>
  <a href="http://weibo.com/u/3034766044"><i class="fa fa-weibo fa-2x" title="我的微博"></i></a>
  <a href="https://github.com/JonyFang"><i class="fa fa-github fa-2x" title="我的Github"></i></a>
  <a href="http://www.douban.com/people/65344909/"><i class="fa fa-coffee fa-2x" title="我的豆瓣"></i></a>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/04/18/data-structure04-stack-and-queue/">数据结构浅析（四）：栈和队列</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/10/data_structure03.linear_list/">数据结构浅析（三）：线性表</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/02/data_structure02.algorithm/">数据结构浅析（二）：算法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/25/data_structure01.the_basic_conception_in_data_structure/">数据结构浅析（一）：数据结构基本概念</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/07/recover_your_local_octopress_repository/">从 Github 恢复 Octopress 到本地</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/12/git_command_and_git_branching_model/">Git 常用命令和 Git Flow 梳理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/09/update_cocoapods/">Cocoapods 版本升级</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/08/octopress_adapt_to_elcapitan/">Octopress 适配 OS X El Capitan</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/16/starting_blog_with_octopress_2/">基于 Octopress &amp; Github Pages 搭建博客（二）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/13/starting_blog_with_octopress_1/">基于 Octopress & Github Pages 搭建博客（一）</a>
      </li>
    
  </ul>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - Jony Fang -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'JonyFang';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://jonyfang.com/blog/2016/04/18/data-structure04-stack-and-queue/';
        var disqus_url = 'http://jonyfang.com/blog/2016/04/18/data-structure04-stack-and-queue/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
